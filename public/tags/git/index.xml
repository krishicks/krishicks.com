<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Git on krishicks.com</title>
    <link>http://www.krishicks.com/tags/git/</link>
    <description>Recent content in Git on krishicks.com</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 06 Apr 2012 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://www.krishicks.com/tags/git/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>git exec</title>
      <link>http://www.krishicks.com/post/exec/</link>
      <pubDate>Fri, 06 Apr 2012 00:00:00 +0000</pubDate>
      
      <guid>http://www.krishicks.com/post/exec/</guid>
      <description>&lt;p&gt;(Update #1 below)&lt;/p&gt;

&lt;p&gt;Say you&amp;rsquo;re going to do an interactive rebase where you&amp;rsquo;re going to be squashing commits or reordering them. During this process you may want Git to execute a command after applying certain items of the todo list. An example of this would be when you want to run &lt;code&gt;rake&lt;/code&gt; or similar to ensure a newly-squashed commit is still green.&lt;/p&gt;

&lt;p&gt;You can do this by adding a task to the todo list, &lt;code&gt;exec&lt;/code&gt;, followed by the command you&amp;rsquo;d like Git to run at that point in the rebase. If the command you specify should return a non-zero exit code, Git will pause the rebase and allow you to sort it out, in the same way that it pauses when a conflict arises while applying the todo list during any other rebase.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an example of the above situation, where two commits are going to be squashed, and I want Git to run &lt;code&gt;rake&lt;/code&gt; after it does the squash.&lt;/p&gt;

&lt;p&gt;Pre-edits, this would look like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pick dad8d12 Commit #1
pick f613ac1 Commit #2
pick 58822ee Commit #3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Post-edits, this would look like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pick dad8d12 Commit #1
f f613ac1 Commit #2
x rake
pick 58822ee Commit #3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What happens here is Git will fixup Commit #2 into Commit #1, creating a new commit, then run &lt;code&gt;rake&lt;/code&gt;. If &lt;code&gt;rake&lt;/code&gt; returns a zero exit code, Git applies Commit #3 and completes the rebase. If &lt;code&gt;rake&lt;/code&gt; had returned a non-zero exit code, Git would have paused the rebase operation at that point, allowing any necessary changes to be made to the HEAD commit, which is the squashed #1/#2.&lt;/p&gt;

&lt;p&gt;I typically do this separate from doing an initial rebase, where I rebased and made a change to Commit #1 and had to resolve conflicts throughout the rest of the commits. This way I can keep my head straight while doing the rebase, then fix anything I missed as a second operation.&lt;/p&gt;

&lt;p&gt;Update #1: As of Git 1.7.12 you can pass &lt;code&gt;-x &amp;lt;cmd&amp;gt;&lt;/code&gt; to &lt;code&gt;git rebase -i&lt;/code&gt; to have Git run the exec command after every commit in the resulting history: &lt;code&gt;git rebase -i &amp;lt;treeish&amp;gt; -x &amp;lt;cmd&amp;gt;&lt;/code&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>