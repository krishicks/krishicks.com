<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>krishicks.com</title>
    <link>http://www.krishicks.com/tags/git/index.xml</link>
    <description>Recent content on krishicks.com</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://www.krishicks.com/tags/git/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Using git subtree with gh-pages</title>
      <link>http://www.krishicks.com/post/subtree-gh-pages/</link>
      <pubDate>Sat, 16 May 2015 00:00:00 +0000</pubDate>
      
      <guid>http://www.krishicks.com/post/subtree-gh-pages/</guid>
      <description>&lt;p&gt;I recently switched to using &lt;a href=&#34;http://www.gohugo.io&#34;&gt;Hugo&lt;/a&gt; to generate this site and needed a strategy to publish it. Previously I was using &lt;a href=&#34;http://www.octopress.org&#34;&gt;Octopress&lt;/a&gt; which has scripts for managing the gh-pages branch automatically. The documentation on gohugo.io shows a workflow that uses &lt;code&gt;git subtree&lt;/code&gt;, a tool I knew about but had never actually used before. I found the &lt;a href=&#34;http://gohugo.io/tutorials/github-pages-blog#configure-git-workflow:fcefb200141ace3e7bfd6542457b7a72&#34;&gt;tutorial&lt;/a&gt; on the gohugo.io page to be confusing. Here, I describe the approach I used instead.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;My goal is to have a clean &lt;code&gt;gh-pages&lt;/code&gt; branch that contains the minimum content it needs to have a meaningful history, and a &lt;code&gt;master&lt;/code&gt; branch that makes sense.&lt;/p&gt;

&lt;p&gt;The first thing to do is generate the site in &lt;code&gt;public/&lt;/code&gt; by running &lt;code&gt;hugo&lt;/code&gt; while on &lt;code&gt;master&lt;/code&gt; and in the root directory of the repository:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout master
$ hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point, create an orphaned &lt;code&gt;gh-pages&lt;/code&gt; branch:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout --orphan gh-pages
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Note: the &lt;code&gt;gh-pages&lt;/code&gt; branch won&amp;rsquo;t show up in &lt;code&gt;git branch&lt;/code&gt; yet. Don&amp;rsquo;t worry about that.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;If you check &lt;code&gt;git status&lt;/code&gt; you&amp;rsquo;ll see a bunch of staged filesâ€“the contents that were in &lt;code&gt;master&lt;/code&gt;. Unstage these with &lt;code&gt;git reset&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git reset .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now everything that was staged will be untracked. Clean up those untracked files with &lt;code&gt;git clean&lt;/code&gt;, &amp;nbsp;&lt;strong&gt;excluding public&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clean --force -d --exclude public
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you should see &lt;code&gt;public/&lt;/code&gt; as the only untracked directory.&lt;/p&gt;

&lt;p&gt;Of course, GitHub Pages wants the content that&amp;rsquo;s currently in &lt;code&gt;public/&lt;/code&gt; as the root of the &lt;code&gt;gh-pages&lt;/code&gt; branch. Let&amp;rsquo;s make that happen. Copy the contents of &lt;code&gt;public/&lt;/code&gt; to the current directory with the tool of your choice, like &lt;code&gt;mv&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mv public/* .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point you can safely get rid of &lt;code&gt;public/&lt;/code&gt;, &amp;nbsp;so run &lt;code&gt;git clean&lt;/code&gt; again, this time only including &lt;code&gt;public&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clean --force -d public # or just rm -r public
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you&amp;rsquo;re in a position to add everything that was in &lt;code&gt;public/&lt;/code&gt;, and is now in the current directory, to make the initial commit. I used &amp;ldquo;Generate site&amp;rdquo; as the message:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add .
$ git commit -m &amp;quot;Generate site&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Note: Only after making the above commit will the &lt;code&gt;gh-pages&lt;/code&gt; branch appear in &lt;code&gt;git branch&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Now push the &lt;code&gt;gh-pages&lt;/code&gt; branch to origin:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git push -u origin gh-pages:gh-pages
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point your GitHub Pages site will be generated by GitHub, and will be live shortly.&lt;/p&gt;

&lt;p&gt;The following steps are what we&amp;rsquo;ll do to make re-generating and updating the site an easy affair. First, check out &lt;code&gt;master&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that the branch is on the remote, we&amp;rsquo;ll add it as a subtree under &lt;code&gt;public/&lt;/code&gt; on &lt;code&gt;master&lt;/code&gt;. Be sure to replace the &lt;code&gt;&amp;lt;placeholder&amp;gt;&lt;/code&gt; with your own repo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git subtree add --prefix public &amp;lt;repo_url&amp;gt; gh-pages
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you &lt;code&gt;ls public&lt;/code&gt; you&amp;rsquo;ll see the content generated by hugo, and if you &lt;code&gt;git log -2&lt;/code&gt; you&amp;rsquo;ll see the commit you made on &lt;code&gt;gh-pages&lt;/code&gt; in addition to the commit that added the subtree to &lt;code&gt;master&lt;/code&gt;. Push &lt;code&gt;master&lt;/code&gt; and you&amp;rsquo;re all set:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git push origin master:master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now each time you update something in &lt;code&gt;content/&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;commit the changes to &lt;code&gt;content/&lt;/code&gt; on &lt;code&gt;master&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;re-generate the site with &lt;code&gt;hugo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;commit the changes to &lt;code&gt;public/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;push the changes to the subtree (which will update &lt;code&gt;gh-pages&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;push the changes to &lt;code&gt;master&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add content
$ git commit -m &amp;quot;Added insightful post on the social lives of kittens&amp;quot;
$ hugo
$ git add public
$ git commit -m &amp;quot;Regenerate site&amp;quot;
$ git subtree push --prefix public &amp;lt;repo_url&amp;gt; gh-pages
$ git push origin master:master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now when you look at the history of &lt;code&gt;gh-pages&lt;/code&gt;, &amp;nbsp;all you&amp;rsquo;ll see are the generate/regenerate commits:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git fetch gh-pages
$ git log gh-pages
102c92b 6 minutes ago Kris Hicks | Regenerate site
af759b6 10 minutes ago Kris Hicks | Regenerate site
69045e6 2 hours ago Kris Hicks | Generate site
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Whereas on &lt;code&gt;master&lt;/code&gt; you&amp;rsquo;ll see the changes to the content, in addition to the changes on the subtree:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log master
1df64be 7 minutes ago Kris Hicks | Regenerate site
d244956 8 minutes ago Kris Hicks | Update phone-interviews post with HN link
66c4e29 11 minutes ago Kris Hicks | Regenerate site
bea8982 11 minutes ago Kris Hicks | Update rerere post
456c79e 14 minutes ago Kris Hicks | Add static/
cfb98dc 18 minutes ago Kris Hicks | Add &#39;public/&#39; from commit &#39;69045e6db8a929e0476c7553917981e3c9545c4e&#39;
69045e6 2 hours ago Kris Hicks | Generate site
daf97fc 3 hours ago Kris Hicks | Add keybase.txt
483bfec 3 hours ago Kris Hicks | Add CNAME
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This makes more sense to me than the approach listed on the gohugo.io tutorial, which leaves you with weird merge commits and messy history otherwise.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>rewinding git pull</title>
      <link>http://www.krishicks.com/post/rewinding-git-pull/</link>
      <pubDate>Mon, 09 Jul 2012 00:00:00 +0000</pubDate>
      
      <guid>http://www.krishicks.com/post/rewinding-git-pull/</guid>
      <description>&lt;p&gt;If you&amp;rsquo;re using a rebase strategy for the first time you may run &lt;code&gt;git pull&lt;/code&gt; in a situation where Git practically tells you to do it, but you don&amp;rsquo;t actually want to do it.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;The situation is described below, and the method to unwind it follows. I&amp;rsquo;ve added pictures of the branches between hashes to make it clear what the state of the world is at any given point prior to or after running a particular command, which I hope makes it easier to follow.&lt;/p&gt;

&lt;p&gt;First, you update master, as it&amp;rsquo;s out of date:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#############################
A--B--C--D origin/master
A--B--C master
#############################

(master) $ git pull
Updating C..D
Fast-forward
...snip...

#############################
A--B--C--D origin/master
A--B--C--D master
#############################
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You create and checkout a topic branch, topicA:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(master) $ git checkout -b topicA
Switched to a new branch &#39;topicA&#39;

#############################
A--B--C--D origin/master
A--B--C--D master
          \
           topicA
#############################
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You make some changes, commit, and push it to origin.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(topicA) $ git commit -am &amp;quot;Changed README&amp;quot;

#############################
A--B--C--D origin/master
A--B--C--D master
          \
           E topicA
#############################

(topicA) $ git push -u origin
(topicA) Counting objects: 28, done.
...snip...
(topicA)  * [new branch]      topicA -&amp;amp;gt; topicA
(topicA) Branch topicA set up to track remote branch topicA from origin.

#############################
A--B--C--D origin/master
A--B--C--D master
          \
           E topicA
A--B--C--D--E origin/topicA
#############################
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point you have your local topicA, and also origin has a copy of topicA:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(topicA) $ git branch -a
* topicA
remotes/origin/topicA
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You continue doing work, making more commits on your branch. Some time has passed since you branched from master, and another commit, F, has been pushed to origin/master.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(topicA) $ git fetch # to update your local repository&#39;s knowledge of the remote

#############################
A--B--C--D--F origin/master
A--B--C--D master
          \
           E--G--H topicA
A--B--C--D--E origin/topicA
#############################
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point you want to rebase on top of origin/master to get the updates (in this case, F).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git rebase origin/master
First, rewinding head to replay your work on top of it...
...snip...

#############################
A--B--C--D--F origin/master
             \
              E&#39;--G&#39;--H&#39; topicA
A--B--C--D master
A--B--C--D--E origin/topicA
#############################
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then you want to push your updated topicA, with your new commits and the new commit from origin/master up to origin:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The following assumes you have &lt;code&gt;git config.push default upstream&lt;/code&gt; set. This configuration parameter limits the branch that git will attempt to push. I highly recommend you set that value as the default is to push &lt;em&gt;all&lt;/em&gt; branches, which you probably do not want.&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(topicA) $ git push
To git@github.com:intentmedia/code.git
! [rejected]        topicA -&amp;amp;gt; topicA (non-fast-forward)
error: failed to push some refs to &#39;git@github.com:krishicks/krishicks.git&#39;
To prevent you from losing history, non-fast-forward updates were rejected
Merge the remote changes (e.g. &#39;git pull&#39;) before pushing again.  See the
&#39;Note about fast-forwards&#39; section of &#39;git push --help&#39; for details.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is where trouble sets in.&lt;/p&gt;

&lt;p&gt;First, Git tells you the push was rejected because you would have lost history. Then comes the troublesome line: &amp;ldquo;Merge the remote changes (e.g. &amp;lsquo;git pull&amp;rsquo;) before pushing again.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;If you were working on master and made some commits, and someone else made some commits on master as well and pushed before you did, you would end up with the same situation as above. The push would be rejected because you don&amp;rsquo;t have the commits that the other person made. Thus, if your push were to succeed their work would be lost on origin/master. This is what Git is referring to when it says &amp;ldquo;To prevent you from losing history..&amp;rdquo; The history that would be lost would be the work the other person did.&lt;/p&gt;

&lt;p&gt;In the situation we&amp;rsquo;ve been building up, making commits and rebasing topicA, you&amp;rsquo;re the only person committing to the branch and the history you would &amp;ldquo;lose&amp;rdquo; is the set of pre-rebase commits that you pushed to the remote originally (in this case, E). You&amp;rsquo;ve overwritten E with E&amp;rsquo; during the rebase, and Git doesn&amp;rsquo;t want you to lose the E that&amp;rsquo;s on the remote.&lt;/p&gt;

&lt;p&gt;What you should do in this situation is &lt;code&gt;git push -f&lt;/code&gt; to force-push the branch. You know you&amp;rsquo;re going to lose E that&amp;rsquo;s on the remote, but that&amp;rsquo;s fine because you have E&amp;rsquo; on your local topicA. You intend to replace whatever is on the remote with whatever you have locally.&lt;/p&gt;

&lt;p&gt;The problem is that it says to do a &lt;code&gt;git pull&lt;/code&gt;, which will pull the remote E into your local, which you don&amp;rsquo;t want. That will give you a merge commit, I:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A--B--C--D--F origin/master
             \
              E&#39;--G&#39;--H&#39; topicA
                       \
                        I
A--B--C--D master      /
A--B--C--D------------E origin/topicA
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you did a git log at this point you&amp;rsquo;d see that the merge commit I brought in E, which has the same message but a different SHA than your rebased E&amp;rsquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(topicA) $ git log --graph --oneline
* I Merge branch &#39;origin/topicA&#39; into topicA
|
| * E
* | H&#39;
* | G&#39;
* | E&#39;
|/
* D
* C
* B
* A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, how do you fix this? You can hard reset back to H&amp;rsquo;, which gets rid of the merge commit, but &lt;strong&gt;only if you didn&amp;rsquo;t already make more commits after the faulty &lt;code&gt;git pull&lt;/code&gt;.&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(topicA) $ git reset --hard H&#39; # Only if you didn&#39;t make any more commits!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you have made commits after, with your log looking like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(topicA) $ git log --graph --oneline
* K
* J
* I Merge branch &#39;origin/topicA&#39; into topicA
|
| * E
* | H&#39;
* | G&#39;
* | E&#39;
|/
* D
* C
* B
* A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You need to use the two-argument form of &lt;a href=&#34;https://pivotallabs.com/users/khicks/blog/articles/2118-git-rebase-onto&#34; title=&#34;git rebase --onto&#34;&gt;git rebase &amp;ndash;onto&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(topicA) $ git rebase --onto H&#39; J~1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That will get rid of the merge commit, leaving you with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(topicA) $ git log --graph --oneline
* K
* J
* H&#39;
* G&#39;
* E&#39;
* D
* C
* B
* A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now you can &lt;code&gt;git push -f&lt;/code&gt;. The &lt;a href=&#34;http://linux.die.net/man/1/git-push&#34; title=&#34;docs on git-push&#34;&gt;docs on git-push&lt;/a&gt; (or &lt;code&gt;git push --help&lt;/code&gt;) do give you a better explanation than the message when the push is rejected, in the section NOTE ABOUT FAST-FORWARDS.&lt;/p&gt;

&lt;p&gt;A simple rule about &lt;code&gt;git pull&lt;/code&gt; is to not ever use it unless you&amp;rsquo;re on master and have made no commits that put you ahead of origin/master, which you can easily tell with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(master) $ git fetch
(master) $ git log @{u}..
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(master) $ git fetch
(master) $ git status
# On branch master
nothing to commit (working directory clean)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the result from &lt;code&gt;git log @{u}&lt;/code&gt; is empty or you don&amp;rsquo;t get &amp;ldquo;# Your branch is ahead of &amp;lsquo;origin/master&amp;rsquo; by  commit(s)&amp;rdquo; message after &lt;code&gt;git status&lt;/code&gt;, you&amp;rsquo;re OK to &lt;code&gt;git pull&lt;/code&gt;. In no other case do you need to, or should you, &lt;code&gt;git pull&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;I generally recommend always working on a topic branch and keeping master clean to avoid accidentally running &lt;code&gt;git push -f&lt;/code&gt; on master, and to enforce the idea that after you fetch, you&amp;rsquo;re rebasing on top of origin/master directly instead of doing &lt;code&gt;git pull --rebase&lt;/code&gt; while on master, which hides the fact that you&amp;rsquo;re rebasing on top of origin/master.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>git quick tips</title>
      <link>http://www.krishicks.com/post/quick-tips/</link>
      <pubDate>Tue, 03 Jul 2012 00:00:00 +0000</pubDate>
      
      <guid>http://www.krishicks.com/post/quick-tips/</guid>
      <description>&lt;p&gt;The following are things I found very helpful, which you also may find make your day-to-day usage of Git more enjoyable.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;go-headless&#34;&gt;Go HEADless&lt;/h2&gt;

&lt;p&gt;In many (and perhaps all) cases HEAD is implied when no ref is given, such as the following equivalent statements:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log origin/master..HEAD
$ git log origin/master..
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;upstream-reference&#34;&gt;Upstream reference&lt;/h2&gt;

&lt;p&gt;Before you start referring to the upstream, you&amp;rsquo;ll want to do a &lt;code&gt;git fetch&lt;/code&gt; to update your refs/heads:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git fetch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You only need to do this once in a while, or whenever you know the upstream to have changed.&lt;/p&gt;

&lt;p&gt;You can refer to the upstream of any branchname or otherwise symbolic-ref by appending &lt;code&gt;@{u}&lt;/code&gt; to the ref, such as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log master@{u}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you just want the upstream of the current branch, whatever it may be, you can replace master from above with HEAD:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log HEAD@{u}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;upstream-difference&#34;&gt;Upstream difference&lt;/h2&gt;

&lt;p&gt;Often, I&amp;rsquo;ll want to see what commits are on upstream that I don&amp;rsquo;t have. I usually will do this via:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log @{u}..
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which, when on master, is equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log origin/master..HEAD
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see the reverse difference, or the commits are on the remote that you don&amp;rsquo;t have, by reversing the range:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log ..@{u}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which, again on master, is equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log HEAD..origin/master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;To see the full list of formats recognizable, see &lt;code&gt;git revisions --help&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;If you want to see both of the above at the same time, you can use &lt;code&gt;git log&lt;/code&gt; with the &amp;ndash;left-right parameter. I&amp;rsquo;ve also included &amp;ndash;format=&amp;rdquo; and &amp;ndash;oneline (which must be passed in that order), which may be optional depending on your format configuration, but for me are not:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log HEAD@{u}...HEAD --left-right --format=&#39;&#39; --oneline
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which can be shortened to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log @{u}... --left-right --format=&#39;&#39; --oneline
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Note: The above example uses three dots, not two, to show only the commits which are reachable as ancestors of one branch but not the other.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;You can replace HEAD in the above with any symbolic-ref or branchname to use as a reference instead. The output (with the format given previously) will look like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt; e86bd83 D
&amp;lt; 6ea2155 C
&amp;gt; eb2de55 B
&amp;gt; 74829bd A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Commits beginning with &amp;ldquo;&amp;lt;&amp;rdquo; are only on the left side of the triple-dot (in this case, the upstream), commits beginning with &amp;ldquo;&amp;gt;&amp;rdquo; are only on the right side (in this case, the current branch). A..D are the commit messages.&lt;/p&gt;

&lt;h2 id=&#34;is-it-merged&#34;&gt;Is it merged?&lt;/h2&gt;

&lt;p&gt;To find out if a particular branch has been merged into origin/master, you could dig through the log on master and search for it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log origin/master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or, if you knew who would have merged it, you could limit the above with that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log origin/master --author Kris
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I wanted a better way, and I found it. I wanted to see if a particular branch had been merged to master without changing branches or having to dig through a log looking for the merge of the branch.&lt;/p&gt;

&lt;p&gt;The situation that prompted this was that I had a topic branch, topicB, which depended on another topic branch, topicA. I wanted to see if topicA had been merged into master to find out if I could rebase onto master to get up to date, or if I should continue rebasing on top of the branch.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git fetch
$ git branch --contains topicB@{u} -r
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This gives you a list of all the remote branches that can reach (as an ancestor) the ref given. origin/master will be right at the top if the branch has been merged into it.&lt;/p&gt;

&lt;p&gt;Many thanks to &lt;a href=&#34;http://newartisans.com/2008/04/git-from-the-bottom-up/&#34; title=&#34;John Wiegley&#34;&gt;John Wiegley&lt;/a&gt;, &lt;a href=&#34;http://www.git-scm.com/book&#34; title=&#34;Scott Chacon&#34;&gt;Scott Chacon&lt;/a&gt; and &lt;a href=&#34;http://serverfault.com/a/384862&#34; title=&#34;Mark Longair&#34;&gt;Mark Longair&lt;/a&gt; for the sources of the tips.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>rewinding git commit --amend</title>
      <link>http://www.krishicks.com/post/rewinding-git-commit-amend/</link>
      <pubDate>Mon, 25 Jun 2012 00:00:00 +0000</pubDate>
      
      <guid>http://www.krishicks.com/post/rewinding-git-commit-amend/</guid>
      <description>&lt;p&gt;It may come to pass that you will run &lt;code&gt;git commit --amend&lt;/code&gt; by mistake. When this happens, you&amp;rsquo;ll want to unwind the operation you just did.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;In some cases the changes are simple enough that you can use &lt;a href=&#34;http://www.krishicks.com/blog/2012/05/16/git-reset-p/&#34; title=&#34;git reset -p&#34;&gt;git reset -p&lt;/a&gt; to remove those lines from the commit. However, sometimes &lt;code&gt;git reset -p&lt;/code&gt; isn&amp;rsquo;t up to the task, as in the case when the changeset is very large. Luckily, git has a ticker tape of the changes you make to each branch, which is called the reflog.&lt;/p&gt;

&lt;p&gt;The reflog records when the tip of a branch is updated. The tip is updated any time you create a new commit, amend a commit, reset a commit, switch branches, etc. Basically, any time HEAD changes, you will get a reflog entry. The reflog therefore is a great tool for understanding how the repository came to be in a particular state.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git reflog -2&lt;/code&gt; will give you the last two operations that Git performed. In the case of an amend, it will look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;C HEAD@{0}: commit (amend): Something something something commit message
B HEAD@{1}: reset: moving to HEAD~1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;git commit --amend&lt;/code&gt; is kind of shorthand for the following, given changes have been made, and are either in the index or in the working directory:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git stash
$ git reset HEAD~1
$ git stash pop
$ git add .
$ git commit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or, in English:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Save the changes that you want to apply to the HEAD commit off in the stash&lt;/li&gt;
&lt;li&gt;Remove the HEAD commit and put its contents in the index&lt;/li&gt;
&lt;li&gt;Apply the stashed changes to the working directory, adding them to the changes from the commit that was reset&lt;/li&gt;
&lt;li&gt;Make a new commit&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Thus, the last two operations in the reflog are &lt;strong&gt;reset&lt;/strong&gt; and &lt;strong&gt;commit&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;So, what can we do with this? Well, B was HEAD before the amend happened. C is the amended commit. &lt;code&gt;git diff C..B&lt;/code&gt; will show you what changes were applied as part of the amend:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git diff C..B
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From here you can use &lt;code&gt;git apply&lt;/code&gt; to apply the reverse of what you amended earlier to your working tree:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git diff C..B | git apply -
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Note: The hyphen in &lt;code&gt;git apply -&lt;/code&gt; causes &lt;code&gt;git apply&lt;/code&gt; to take stdin as input.&lt;/li&gt;
&lt;li&gt;Extra Note: The arguments to &lt;code&gt;git diff&lt;/code&gt; are given in reverse order, with the later commit happening first to show the reverse of the amend. It&amp;rsquo;s the same as doing &lt;code&gt;git diff B..C -R&lt;/code&gt;, which reverses the diff output. Additionally, the -R argument may be applied to &lt;code&gt;git apply&lt;/code&gt; instead of &lt;code&gt;git diff&lt;/code&gt; to achieve the same effect.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now we can do another amend to put the commit back to where it was before we did the previous amend:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git commit -a --amend -CHEAD
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then, by reversing the order of the refs to &lt;code&gt;git diff&lt;/code&gt;, get the changes we want to apply to the correct commit back:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git diff B..C | git apply -
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And commit as necessary, this time using &amp;ndash;fixup to indicate the correct commit (in this example, A):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git commit -a --fixup A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then you can rebase either now or at a later time to do the &amp;lsquo;amend&amp;rsquo; you had originally intended:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git rebase --i --autosquash A~1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So don&amp;rsquo;t fret when you do an accidental amend. It&amp;rsquo;s just a couple commands away from being unwound and applied to the correct commit.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>rerere</title>
      <link>http://www.krishicks.com/post/rerere/</link>
      <pubDate>Wed, 13 Jun 2012 00:00:00 +0000</pubDate>
      
      <guid>http://www.krishicks.com/post/rerere/</guid>
      <description>&lt;p&gt;There have been times where I performed a rebase and had to resolve conflicts as part of the rebase, and then decided to abort the rebase for one reason or another.&lt;/p&gt;

&lt;p&gt;Without &lt;code&gt;rerere&lt;/code&gt; the next time I went to perform the rebase I&amp;rsquo;d end up having to resolve at least some of the same conflicts I had previously, which is annoying.&lt;/p&gt;

&lt;p&gt;This is where &lt;code&gt;rerere&lt;/code&gt; comes in.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&amp;ldquo;rerere&amp;rdquo; stands for &lt;strong&gt;re&lt;/strong&gt;use &lt;strong&gt;re&lt;/strong&gt;corded &lt;strong&gt;re&lt;/strong&gt;solution.&lt;/p&gt;

&lt;p&gt;What &lt;code&gt;rerere&lt;/code&gt; does is save the resolution of a conflict so that it can be re-applied later if it sees the same conflict again. When Git sees the conflict which it already has a resolution recorded for, it will apply the resolution automatically for you, and give you the opportunity to accept the resolution as applied, or change it.&lt;/p&gt;

&lt;p&gt;Turning it on can be done two ways: set it as a configuration parameter using &lt;code&gt;git config rerere.enabled true&lt;/code&gt;, or use it only when you think you might need it with &lt;code&gt;git rerere&lt;/code&gt; both before and after the resolution of a conflict.&lt;/p&gt;

&lt;p&gt;*A more verbose explanation of &lt;code&gt;rerere&lt;/code&gt; exists in Scott Chacon&amp;rsquo;s &lt;strong&gt;Pro Git&lt;/strong&gt;*.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>git rebase --onto</title>
      <link>http://www.krishicks.com/post/git-rebase-onto/</link>
      <pubDate>Mon, 28 May 2012 00:00:00 +0000</pubDate>
      
      <guid>http://www.krishicks.com/post/git-rebase-onto/</guid>
      <description>&lt;p&gt;Have you ever dug into the &lt;code&gt;git rebase&lt;/code&gt; documentation and noticed there&amp;rsquo;s a three-argument form of it?&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;First, let&amp;rsquo;s look at the two-argument form, and build up to the three-argument form.&lt;/p&gt;

&lt;h2 id=&#34;the-two-argument-form-of-git-rebase-onto&#34;&gt;The two-argument form of git rebase &amp;ndash;onto&lt;/h2&gt;

&lt;p&gt;Say there&amp;rsquo;s a commit C made on master that made a change to a configuration parameter that, it turns out, wasn&amp;rsquo;t actually necessary, so that commit needs to go. For the purposes of this demonstration, commits D and E don&amp;rsquo;t rely upon the changes made in C. &amp;#40;If D or E did rely on C, you&amp;rsquo;d end up with a conflict to resolve, which you&amp;rsquo;d be able to do at that point.&amp;#41;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A--B--C--D--E master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One way to get rid of the offending commit would be to do an interactive rebase, deleting the line that has commit C on it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git rebase -i C~1
delete the line containing commit C
save and close the editor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A quicker way is to use the two-argument &lt;code&gt;git rebase --onto&lt;/code&gt;, as going interactive just to delete a commit &amp;#40;or commits&amp;#41; is a little overkill, and considerably slower to do.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git rebase --onto&lt;/code&gt; takes a new base commit &amp;#40;which the manpage for git-rebase calls newbase&amp;#41; and an old base commit &amp;#40;oldbase&amp;#41; to use for the rebase operation.&lt;/p&gt;

&lt;p&gt;So, what we want to do is tell Git to make commit B the newbase of commit D, making C go away. This looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git rebase --onto B C
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But usually I like to talk about the commits I care about rather than the ones I don&amp;rsquo;t &amp;#40;in this case, I care about B and D, but not C&amp;#41;, so instead of the previous command I use a backreference from D:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git rebase --onto B D~1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This means that everything in the range from B &amp;#40;non-inclusive&amp;#41; to D~1 &amp;#40;inclusive&amp;#41; &lt;em&gt;will be removed&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git rebase --onto&lt;/code&gt; allows you to, in a non-interactive way, change the base of a commit, or &lt;em&gt;rebase&lt;/em&gt; it. If you think about the commits as each having a &lt;strong&gt;base&lt;/strong&gt;, or &lt;strong&gt;parent&lt;/strong&gt; commit, you can see how you might be able to change the base of any commit to be another commit. In doing so, you remove everything that used to be in between the oldbase and the newbase.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s also good to know that it works exactly the same way as if you were to have done an interactive rebase and deleted the commit. Should a conflict arise while performing the rebase, Git will still pause and allow you to resolve the conflict before continuing.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve also used the two-argument form when fixing a mistake: I had a branch from master, topicA, with some commits that I wanted to change via interactive rebase:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A--B master
    \
     C--D--E topicA
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But when I rebased, I went back too far, and rewrote a commit that I had gotten from master:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A--B&#39; master
    \
     C&#39;--D&#39;--E&#39; topicA
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#40;Note that there was no change to the master branch here, just to topicA.&amp;#41;&lt;/p&gt;

&lt;p&gt;What did I do to fix this situation? Well, I can&amp;rsquo;t fix this via interactive rebase. I can, however, fix it via &lt;code&gt;git rebase --onto&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git rebase --onto master C&#39;~1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or, in other words: Replace the oldbase C&amp;rsquo;~1 with the newbase, master &amp;#40;which is HEAD of master, or B&amp;#41;.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s a handy undo mechanism.&lt;/p&gt;

&lt;p&gt;If you forget to give the two-argument form of &amp;ndash;onto its second argument, such as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git rebase --onto master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;..it will be the same as doing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git reset --hard master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;You probably don&amp;rsquo;t want this.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Why is this? The second argument &amp;#40;the oldbase&amp;#41; is required if you want a range of commits to be applied on top of master. Without it, you haven&amp;rsquo;t supplied a range of commits to be applied on top of master, so HEAD of the branch gets reset to the HEAD of master.&lt;/p&gt;

&lt;p&gt;What that means is any commits you have on your branch will be removed from the branch, and the branch will resemble master at that point. These commits are still in Git until garbage collection happens, accessible via the reflog &amp;#40;&lt;code&gt;git reflog&lt;/code&gt;&amp;#41;.&lt;/p&gt;

&lt;h1 id=&#34;part-two&#34;&gt;Part Two:&lt;/h1&gt;

&lt;h2 id=&#34;the-three-argument-form-of-git-rebase-onto&#34;&gt;The three-argument form of git rebase &amp;ndash;onto&lt;/h2&gt;

&lt;p&gt;Say there is a branch &amp;lsquo;topicA&amp;rsquo; that diverges from master at some point:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A--B--C--D--E master
    \
     F--G--H topicA
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s also say that someone else has branched from topicA to create topicB, and added more commits:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A--B--C--D--E master
    \
     F--G--H topicA
            \
             I--J--K--L--M topicB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is an example of a real-world case I came across, where topicA had only a couple very large commits that were hard to digest and could have been split into many smaller commits. topicB was created as a continuation of the work done on topicA.&lt;/p&gt;

&lt;p&gt;I checked out my own local copy of topicA, and through much interactive rebasing and prodigious use of &lt;code&gt;git add -e&lt;/code&gt;, I was able to split topicA into smaller commits, making topicC:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A--B--C--D--E master
   |         \
   |          F--G--H topicA
   |                 \
   |                  I--J--K--L--M topicB
   |
   N--O--P--Q--R--S--T--U--V--W topicC
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I talked with the person that made topicA and we agreed that my branch topicC should take the place of topicA. But what to do about the work that was done on topicB?&lt;/p&gt;

&lt;p&gt;The operation that we wanted to do is: make topicC the new base of topicB, cutting it at the point topicB diverged from topicA, which looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A--B--C--D--E master
   |         \
   |          F--G--H topicA
   |                 \
   |                  I--J--K--L--M topicB
   |
   N--O--P--Q--R--S--T--U--V--W--I&#39;--J&#39;--K&#39;--L&#39;--M&#39; topicC
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The five commits from topicB &amp;#40;I through M&amp;#41;, get played on top of topicC, starting from where topicB diverged from topicA, to create I&amp;rsquo;, J&amp;rsquo;, K&amp;rsquo;, L&amp;rsquo;, and M&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;The command to do this is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git rebase --onto topicC topicA topicB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where topicC is the newbase, topicA is the oldbase, and topicB is the reference for what HEAD of topicC will become.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>git add -e</title>
      <link>http://www.krishicks.com/post/git-add-e/</link>
      <pubDate>Mon, 21 May 2012 00:00:00 +0000</pubDate>
      
      <guid>http://www.krishicks.com/post/git-add-e/</guid>
      <description>&lt;p&gt;&lt;code&gt;git add -e&lt;/code&gt; is like &lt;code&gt;git add -p&lt;/code&gt;, except instead of adding things at the hunk level, you edit the entire patch at once.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;Or, in other words, whereas &lt;code&gt;git add -p&lt;/code&gt; will show you each hunk for every file and ask what you want to do for each of them, &lt;code&gt;git add -e&lt;/code&gt; will show you the entire patch and allow you to edit it at will. I used this trick to recently split apart one massive commit into 28 smaller, digestible ones.&lt;/p&gt;

&lt;p&gt;Say you&amp;rsquo;ve replaced a line containing &amp;ldquo;baz&amp;rdquo; with one containing &amp;ldquo;bar&amp;rdquo;. When you &lt;code&gt;git add -e&lt;/code&gt;, you&amp;rsquo;ll be presented with a diff like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo
- baz
+ bar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From here you can decide, actually, you don&amp;rsquo;t want to delete baz, you just want to add bar. And you want to add it above baz.&lt;/p&gt;

&lt;p&gt;From this spot you can just change the minus to a space, making that line context for the diff. Then you can move the line that adds bar above baz, with this result:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo
+ bar
baz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After saving and closing the editor you&amp;rsquo;ll be able to look at the result of your work in the index with &lt;code&gt;git diff --cached&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo
+ bar
baz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the line you made into context remains in your working directory, which you can see with &lt;code&gt;git diff&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo
bar
-baz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But what if you end up modifying the diff in a way that makes it a patch that doesn&amp;rsquo;t apply? Git&amp;rsquo;s got you covered there.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say that when you moved bar above baz, after removing the minus from baz, you added an extra line on accident, making the patch invalid:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo

+ bar
baz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you save and close the editor Git will tell you of the problem:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error: patch failed: &amp;amp;lt;some_filename&amp;amp;gt;:1
error: file.txt: patch does not apply
fatal: Could not apply &#39;.git/ADD_EDIT.patch&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In which case you&amp;rsquo;ll be able to attempt the &lt;code&gt;add -e&lt;/code&gt; again, as Git will not have made any changes to the working directory or index at this point.&lt;/p&gt;

&lt;p&gt;In some cases Git will attempt to apply the patch and give you the option of retrying the add, re-opening the editor with the modified .git/ADD_EDIT.patch if you choose to retry. If you don&amp;rsquo;t choose to retry, Git will delete .git/ADD_EDIT.patch.&lt;/p&gt;

&lt;p&gt;In addition to editing the patch wholesale via &lt;code&gt;git add -e&lt;/code&gt;, you can also choose &lt;em&gt;during &lt;code&gt;git add -p&lt;/code&gt;&lt;/em&gt; to edit a particular hunk manually by choosing &amp;lsquo;e&amp;rsquo; to edit it instead of simply adding it via &amp;lsquo;a&amp;rsquo;. You can also add a file glob to the end of &lt;code&gt;add -e&lt;/code&gt; as you would any other command to limit the size of the patch you&amp;rsquo;re about to edit.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>git reset -p</title>
      <link>http://www.krishicks.com/post/git-reset-p/</link>
      <pubDate>Wed, 16 May 2012 00:00:00 +0000</pubDate>
      
      <guid>http://www.krishicks.com/post/git-reset-p/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve been using &lt;code&gt;git reset -p&lt;/code&gt; a lot recently and I think it makes sense to clarify what it is that it does because when I first started using it I found it a little confusing.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;I sometimes realize that an earlier commit contains some change that I don&amp;rsquo;t want, so I want to remove it from the commit. This also works when not rebasing, so for simplicity I&amp;rsquo;ll use an example where the commit to be modified is already HEAD. Previously I would have done:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git reset HEAD~1
git add -p
git commit -C &amp;lt;treeish&amp;gt;
git checkout .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or, in English:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;take off the HEAD commit, adding it to the working directory&lt;/li&gt;
&lt;li&gt;add back the parts you want to keep&lt;/li&gt;
&lt;li&gt;make a new commit using the message from what used to be the HEAD commit&lt;/li&gt;
&lt;li&gt;throw away the changes you didn&amp;rsquo;t want&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With git reset -p this process is a little different. Here&amp;rsquo;s what it looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git reset -p HEAD~1
git commit --amend -C HEAD
git checkout .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, in English:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;apply to the index the negations of certain parts of the HEAD commit&lt;/li&gt;
&lt;li&gt;amend the HEAD commit with the negations&lt;/li&gt;
&lt;li&gt;throw away the changes you don&amp;rsquo;t want&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;How does this work?&lt;/p&gt;

&lt;p&gt;In the second example you added &lt;code&gt;-p&lt;/code&gt; to the &lt;code&gt;reset&lt;/code&gt; command. This will reset only parts of the original commit, leaving it intact otherwise. That&amp;rsquo;s worth stating a different way: When you &lt;code&gt;reset -p&lt;/code&gt;, &lt;strong&gt;the original commit remains unchanged&lt;/strong&gt;. The only changes are made to your working directory and index.&lt;/p&gt;

&lt;p&gt;The trick is to know what you&amp;rsquo;re doing when you&amp;rsquo;re saying &amp;ldquo;y&amp;rdquo; to a hunk git presents to you for resetting. Say you added a line to the commit originally:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo
+ bar
baz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But you want to get rid of it. When you git reset -p, git will ask you:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo
- bar
baz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apply this hunk to index [y,n,q,a,d,/,e,?]?&lt;/p&gt;

&lt;p&gt;If you say &amp;lsquo;y&amp;rsquo;, Git will apply that hunk to the index. What you also get, however, is the original hunk (that added &amp;ldquo;bar&amp;rdquo;) in your working directory.&lt;/p&gt;

&lt;p&gt;To summarize, your working directory will have:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo
+ bar
baz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While the index has:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo
- bar
baz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While the commit (unchanged, remember) has:
    foo
    + bar
    baz&lt;/p&gt;

&lt;p&gt;You now have a chance to tell git what you want to do, without having done anything to the original commit yet. In the example above, you wanted to get rid of the addition of the &amp;ldquo;bar&amp;rdquo; line. To do that, you want to take what&amp;rsquo;s in the index (the negation of the addition of &amp;ldquo;bar&amp;rdquo;) and apply it to the commit, making it go away:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git commit --amend -C HEAD
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then you still have in your working directory the adding of &amp;ldquo;bar&amp;rdquo;, which in this case you just want to get rid of, so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git checkout .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I like using &lt;code&gt;reset -p&lt;/code&gt; because it makes it really easy to make small changes to a commit, removing something I added or putting back something I deleted.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;reset -p&lt;/code&gt; allows you to more easily get a grip on the changes you&amp;rsquo;ve made and the ones you&amp;rsquo;re about to make. It also makes much better use of Git, in that you can do even more interesting operations when in the resulting state, which I won&amp;rsquo;t go into now as to avoid information overload.&lt;/p&gt;

&lt;p&gt;And there you have it.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>git exec</title>
      <link>http://www.krishicks.com/post/exec/</link>
      <pubDate>Fri, 06 Apr 2012 00:00:00 +0000</pubDate>
      
      <guid>http://www.krishicks.com/post/exec/</guid>
      <description>&lt;p&gt;(Update #1 below)&lt;/p&gt;

&lt;p&gt;Say you&amp;rsquo;re going to do an interactive rebase where you&amp;rsquo;re going to be squashing commits or reordering them. During this process you may want Git to execute a command after applying certain items of the todo list. An example of this would be when you want to run &lt;code&gt;rake&lt;/code&gt; or similar to ensure a newly-squashed commit is still green.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;You can do this by adding a task to the todo list, &lt;code&gt;exec&lt;/code&gt;, followed by the command you&amp;rsquo;d like Git to run at that point in the rebase. If the command you specify should return a non-zero exit code, Git will pause the rebase and allow you to sort it out, in the same way that it pauses when a conflict arises while applying the todo list during any other rebase.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an example of the above situation, where two commits are going to be squashed, and I want Git to run &lt;code&gt;rake&lt;/code&gt; after it does the squash.&lt;/p&gt;

&lt;p&gt;Pre-edits, this would look like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pick dad8d12 Commit #1
pick f613ac1 Commit #2
pick 58822ee Commit #3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Post-edits, this would look like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pick dad8d12 Commit #1
f f613ac1 Commit #2
x rake
pick 58822ee Commit #3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What happens here is Git will fixup Commit #2 into Commit #1, creating a new commit, then run &lt;code&gt;rake&lt;/code&gt;. If &lt;code&gt;rake&lt;/code&gt; returns a zero exit code, Git applies Commit #3 and completes the rebase. If &lt;code&gt;rake&lt;/code&gt; had returned a non-zero exit code, Git would have paused the rebase operation at that point, allowing any necessary changes to be made to the HEAD commit, which is the squashed #1/#2.&lt;/p&gt;

&lt;p&gt;I typically do this separate from doing an initial rebase, where I rebased and made a change to Commit #1 and had to resolve conflicts throughout the rest of the commits. This way I can keep my head straight while doing the rebase, then fix anything I missed as a second operation.&lt;/p&gt;

&lt;p&gt;Update #1: As of Git 1.7.12 you can pass &lt;code&gt;-x &amp;lt;cmd&amp;gt;&lt;/code&gt; to &lt;code&gt;git rebase -i&lt;/code&gt; to have Git run the exec command after every commit in the resulting history: &lt;code&gt;git rebase -i &amp;lt;treeish&amp;gt; -x &amp;lt;cmd&amp;gt;&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>