<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>krishicks.com</title>
    <link>http://www.krishicks.com/</link>
    <description>Recent content on krishicks.com</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 16 May 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://www.krishicks.com/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Using git subtree with gh-pages</title>
      <link>http://www.krishicks.com/post/subtree-gh-pages/</link>
      <pubDate>Sat, 16 May 2015 00:00:00 +0000</pubDate>
      
      <guid>http://www.krishicks.com/post/subtree-gh-pages/</guid>
      <description>&lt;p&gt;I recently switched to using &lt;a href=&#34;http://www.gohugo.io&#34;&gt;Hugo&lt;/a&gt; to generate this site and needed a strategy to publish it. Previously I was using &lt;a href=&#34;http://www.octopress.org&#34;&gt;Octopress&lt;/a&gt; which has scripts for managing the gh-pages branch automatically. The documentation on gohugo.io shows a workflow that uses &lt;code&gt;git subtree&lt;/code&gt;, a tool I knew about but had never actually used before. I found the &lt;a href=&#34;http://gohugo.io/tutorials/github-pages-blog#configure-git-workflow:fcefb200141ace3e7bfd6542457b7a72&#34;&gt;tutorial&lt;/a&gt; on the gohugo.io page to be confusing. Here, I describe the approach I used instead.&lt;/p&gt;

&lt;p&gt;My goal is to have a clean &lt;code&gt;gh-pages&lt;/code&gt; branch that contains the minimum content it needs to have a meaningful history, and a &lt;code&gt;master&lt;/code&gt; branch that makes sense.&lt;/p&gt;

&lt;p&gt;The first thing to do is generate the site in &lt;code&gt;public/&lt;/code&gt; by running &lt;code&gt;hugo&lt;/code&gt; while on &lt;code&gt;master&lt;/code&gt; and in the root directory of the repository:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout master
$ hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point, create an orphaned &lt;code&gt;gh-pages&lt;/code&gt; branch:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout --orphan gh-pages
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Note: the &lt;code&gt;gh-pages&lt;/code&gt; branch won&amp;rsquo;t show up in &lt;code&gt;git branch&lt;/code&gt; yet. Don&amp;rsquo;t worry about that.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;If you check &lt;code&gt;git status&lt;/code&gt; you&amp;rsquo;ll see a bunch of staged files–the contents that were in &lt;code&gt;master&lt;/code&gt;. Unstage these with &lt;code&gt;git reset&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git reset .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now everything that was staged will be untracked. Clean up those untracked files with &lt;code&gt;git clean&lt;/code&gt;, &amp;nbsp;&lt;strong&gt;excluding public&lt;/strong&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clean --force -d --exclude public
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you should see &lt;code&gt;public/&lt;/code&gt; as the only untracked directory.&lt;/p&gt;

&lt;p&gt;Of course, GitHub Pages wants the content that&amp;rsquo;s currently in &lt;code&gt;public/&lt;/code&gt; as the root of the &lt;code&gt;gh-pages&lt;/code&gt; branch. Let&amp;rsquo;s make that happen. Copy the contents of &lt;code&gt;public/&lt;/code&gt; to the current directory with the tool of your choice, like &lt;code&gt;mv&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mv public/* .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point you can safely get rid of &lt;code&gt;public/&lt;/code&gt;, &amp;nbsp;so run &lt;code&gt;git clean&lt;/code&gt; again, this time only including &lt;code&gt;public&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clean --force -d public # or just rm -r public
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now you&amp;rsquo;re in a position to add everything that was in &lt;code&gt;public/&lt;/code&gt;, and is now in the current directory, to make the initial commit. I used &amp;ldquo;Generate site&amp;rdquo; as the message:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add .
$ git commit -m &amp;quot;Generate site&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Note: Only after making the above commit will the &lt;code&gt;gh-pages&lt;/code&gt; branch appear in &lt;code&gt;git branch&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Now push the &lt;code&gt;gh-pages&lt;/code&gt; branch to origin:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git push -u origin gh-pages:gh-pages
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point your GitHub Pages site will be generated by GitHub, and will be live shortly.&lt;/p&gt;

&lt;p&gt;The following steps are what we&amp;rsquo;ll do to make re-generating and updating the site an easy affair. First, check out &lt;code&gt;master&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that the branch is on the remote, we&amp;rsquo;ll add it as a subtree under &lt;code&gt;public/&lt;/code&gt; on &lt;code&gt;master&lt;/code&gt;. Be sure to replace the &lt;code&gt;&amp;lt;placeholder&amp;gt;&lt;/code&gt; with your own repo:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git subtree add --prefix public &amp;lt;repo_url&amp;gt; gh-pages
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you &lt;code&gt;ls public&lt;/code&gt; you&amp;rsquo;ll see the content generated by hugo, and if you &lt;code&gt;git log -2&lt;/code&gt; you&amp;rsquo;ll see the commit you made on &lt;code&gt;gh-pages&lt;/code&gt; in addition to the commit that added the subtree to &lt;code&gt;master&lt;/code&gt;. Push &lt;code&gt;master&lt;/code&gt; and you&amp;rsquo;re all set:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git push origin master:master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now each time you update something in &lt;code&gt;content/&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;commit the changes to &lt;code&gt;content/&lt;/code&gt; on &lt;code&gt;master&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;re-generate the site with &lt;code&gt;hugo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;commit the changes to &lt;code&gt;public/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;push the changes to the subtree (which will update &lt;code&gt;gh-pages&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;push the changes to &lt;code&gt;master&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add content
$ git commit -m &amp;quot;Added insightful post on the social lives of kittens&amp;quot;
$ hugo
$ git add public
$ git commit -m &amp;quot;Regenerate site&amp;quot;
$ git subtree push --prefix public &amp;lt;repo_url&amp;gt; gh-pages
$ git push origin master:master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now when you look at the history of &lt;code&gt;gh-pages&lt;/code&gt;, &amp;nbsp;all you&amp;rsquo;ll see are the generate/regenerate commits:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git fetch gh-pages
$ git log gh-pages
102c92b 6 minutes ago Kris Hicks | Regenerate site
af759b6 10 minutes ago Kris Hicks | Regenerate site
69045e6 2 hours ago Kris Hicks | Generate site
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Whereas on &lt;code&gt;master&lt;/code&gt; you&amp;rsquo;ll see the changes to the content, in addition to the changes on the subtree:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log master
1df64be 7 minutes ago Kris Hicks | Regenerate site
d244956 8 minutes ago Kris Hicks | Update phone-interviews post with HN link
66c4e29 11 minutes ago Kris Hicks | Regenerate site
bea8982 11 minutes ago Kris Hicks | Update rerere post
456c79e 14 minutes ago Kris Hicks | Add static/
cfb98dc 18 minutes ago Kris Hicks | Add &#39;public/&#39; from commit &#39;69045e6db8a929e0476c7553917981e3c9545c4e&#39;
69045e6 2 hours ago Kris Hicks | Generate site
daf97fc 3 hours ago Kris Hicks | Add keybase.txt
483bfec 3 hours ago Kris Hicks | Add CNAME
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This makes more sense to me than the approach listed on the gohugo.io tutorial, which leaves you with weird merge commits and messy history otherwise.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Phone Interviews are Useless</title>
      <link>http://www.krishicks.com/post/phone-interviews/</link>
      <pubDate>Fri, 23 May 2014 00:00:00 +0000</pubDate>
      
      <guid>http://www.krishicks.com/post/phone-interviews/</guid>
      <description>&lt;p&gt;&lt;em&gt;See discussion about this post on &lt;a href=&#34;https://news.ycombinator.com/item?id=9111310&#34;&gt;Hacker News&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Yesterday, I did a coding challenge-based phone interview. When it ended, I had a mini retrospective with myself, and thought about what went well, and what didn&amp;rsquo;t go well.&lt;/p&gt;

&lt;p&gt;Mostly, it didn&amp;rsquo;t go well.&lt;/p&gt;

&lt;p&gt;I dislike coding challenges, and interviews that are based around them. As soon as the coding challenge begins, my heartrate jumps and my stress levels rise. It&amp;rsquo;s like being put on stage.&lt;/p&gt;

&lt;p&gt;Often, when doing a coding challenge, I make silly mistakes and find myself forgetting to use idioms. It&amp;rsquo;s only after the interview is over and I&amp;rsquo;ve relaxed a bit that I realize what my errors were and where I deviated from how I&amp;rsquo;d write code normally, and rewrite the code to my usual standard. But at that point the interview&amp;rsquo;s over, and I&amp;rsquo;ve already lost.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m similarly bad at whiteboard coding. I don&amp;rsquo;t ever do it outside of interviews, and I rarely do interviews. I avoided interviewing at Twitter for a long time because I was sure I wouldn&amp;rsquo;t get through the interview process, which I knew to consist of both a phone interview and whiteboard coding. After a couple of my friends joined and I had a chat with an engineering manager there, I figured I&amp;rsquo;d give it a shot. If anything, it&amp;rsquo;d be practice for interviewing, which I&amp;rsquo;m terrible at.&lt;/p&gt;

&lt;p&gt;I didn&amp;rsquo;t get past the phone interview.&lt;/p&gt;

&lt;p&gt;Most of the reason I&amp;rsquo;m so bad at coding challenge-based phone interviews and whiteboard coding is I have very low confidence in them as effective tools for interviewing.&lt;/p&gt;

&lt;p&gt;Coding challenges done over the phone will select for people who are good at doing coding challenges over the phone.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s probably the case that people who use coding challenges over the phone as a tool for interviewing feel differently than me about them. This was illustrated when I had the aforementioned chat with the engineering manager at Twitter. He applied the same low value to coding challenges as me, but knew he&amp;rsquo;d have to go through them to get the job. So he bought and read “Cracking the Coding Interview” to fill his developer toolbox with tools he doesn&amp;rsquo;t usually use, and wouldn&amp;rsquo;t expect to use in the position he was interviewing for, because the interview process expected it of him. He jumped through the hoops because everyone else jumped through the same hoops, and doing that particular bit of acrobatics was what everyone else wanted from their new hires. Sure, someone might be a great developer in their own right, but &lt;em&gt;can they jump through the hoops?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;At Pivotal, the gating portion of the interview is done differently from any other place I&amp;rsquo;ve interviewed at. The interview begins with, instead of a coding challenge, a TDD challenge: the interviewee is presented with a few failing tests for a reasonably simple problem, sitting side by side (&lt;em&gt;pairing&lt;/em&gt;) with the interviewer in a typical work environment. The interviewee explains what kind of code they&amp;rsquo;d write to pass each test, and the interviewer does the typing. When all the tests pass, the interviewee gets to add new tests of their own, since there are certain tests that are missing (by design). This system allows the candidate to get a good idea of what they&amp;rsquo;d be doing day-to-day (pairing, TDD) in a realistic work environment. It also allows the interviewer to get a better idea of how the candidate approaches problem-solving.&lt;/p&gt;

&lt;p&gt;When I was interviewing for my replacement at DaisyBill, I opted for a similar approach. I took an actual production feature I developed, copied a subset of the tests I wrote for the feature, and left a shell of the implementation for the interviewee to use as a starting point. This made for a repeatable, real-world-based, effective interview.&lt;/p&gt;

&lt;p&gt;For more reading on effective interview processes, I recommend reading about &lt;a href=&#34;http://ejohn.org/blog/project-based-interviews&#34;&gt;Project-Based Interviews&lt;/a&gt; and &lt;a href=&#34;https://github.com/blog/1269-the-github-hiring-experience&#34;&gt;The GitHub Hiring Experience&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>On Consulting</title>
      <link>http://www.krishicks.com/post/on-consulting/</link>
      <pubDate>Sun, 17 Mar 2013 00:00:00 +0000</pubDate>
      
      <guid>http://www.krishicks.com/post/on-consulting/</guid>
      <description>

&lt;p&gt;After four years being a consultant I jumped ship and joined a startup.&lt;/p&gt;

&lt;p&gt;In this post I describe my time as a consultant, what I learned during the experience, and why I got out. If you’re considering joining a consultancy, this post is for you.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The consulting I refer to in this post is specifically software consulting, though I believe it applies to other facets of consulting as well.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;in-the-beginning:d0e0ec411dac0f37b163e04611066dd6&#34;&gt;In the beginning&lt;/h3&gt;

&lt;p&gt;Prior to consulting I worked at a company where I was the only developer. I wasn’t a developer when I joined, but over the course of about a year I taught myself to program in Ruby and that became my full-time job. I made some good software but never felt truly satisfied with the pace of my progress. I wanted to be better, faster. I wanted to learn from and work with other people.&lt;/p&gt;

&lt;p&gt;That is where my consulting journey began.&lt;/p&gt;

&lt;h3 id=&#34;thoughtworks:d0e0ec411dac0f37b163e04611066dd6&#34;&gt;ThoughtWorks&lt;/h3&gt;

&lt;p&gt;I joined ThoughtWorks in 2009 after having been to a few of the Chi.rb meetups they hosted.&lt;/p&gt;

&lt;p&gt;Soon after I joined I was put on a project in Atlanta. The team I joined was exactly what I was looking for: 30 or so developers who were all much more experienced than I was, working on a very large Rails codebase.&lt;/p&gt;

&lt;p&gt;It was my first time pairing, doing TDD, doing Rails, and being a consultant.&lt;/p&gt;

&lt;p&gt;Though, to be honest, I wasn’t really a consultant then. I was a pretty green developer that was easily absorbed into a large team at a reduced rate. In the first 6 months on that project I was doing more learning than giving much back to the project. I had to learn the stack (Rails, JavaScript, MySQL), the tools (Subversion, TextMate), testing (RSpec, Selenium), and the method (agile, TDD, pairing) in addition to Object-oriented design and a very large domain model.&lt;/p&gt;

&lt;p&gt;I wasn’t a consultant in the sense of being an expert in a domain or a technology, lending my expertise to the client to help them grow. I was a consultant purely in the sense that I was being flown in on a weekly basis to the client’s site to work on their application.&lt;/p&gt;

&lt;p&gt;The client had their own developers, but they were all more senior than I was. They knew the stack, the tools, the domain better, having been there for years already.&lt;/p&gt;

&lt;p&gt;My experience on that project set a precedent for me that gave me a false idea of what it meant to be a consultant.&lt;/p&gt;

&lt;p&gt;I worked on a few other projects at ThoughtWorks, all with a similar theme. My knowledge grew and I became a better developer, but I didn’t become a better consultant. I didn’t even know what it meant to be a consultant then, let alone a good one.&lt;/p&gt;

&lt;h3 id=&#34;pivotal-labs:d0e0ec411dac0f37b163e04611066dd6&#34;&gt;Pivotal Labs&lt;/h3&gt;

&lt;p&gt;I joined Pivotal Labs in 2011.&lt;/p&gt;

&lt;p&gt;After all the time I spent at ThoughtWorks becoming a better developer, I continued in the same fashion on joining Pivotal.&lt;/p&gt;

&lt;p&gt;I worked on a few projects, some with only a couple client developers, some with none, one which was purely staff-augmentation (meaning the client wanted us purely to increase their capacity to deliver software, not necessarily to teach them how to write it), all which kept the idea in my head that being a consultant meant writing good software, and no more.&lt;/p&gt;

&lt;p&gt;It wasn’t until later, while still at Pivotal, that it was impressed upon me what it meant to be a consultant.&lt;/p&gt;

&lt;h3 id=&#34;in-the-end:d0e0ec411dac0f37b163e04611066dd6&#34;&gt;In the end&lt;/h3&gt;

&lt;p&gt;One of the best developers I’ve worked with to date also happens to be one of the best consultants I’ve worked with to date.&lt;/p&gt;

&lt;p&gt;It was from him that I learned that the duty of a consultant is not simply to join a project, write code, and eventually exit, as had been my experience for the three previous years being a consultant.&lt;/p&gt;

&lt;p&gt;I thought my job as a consultant was to write the best code I could, to do the best job I could for the client. That’s how I thought I best delivered value.&lt;/p&gt;

&lt;p&gt;I was wrong.&lt;/p&gt;

&lt;p&gt;Consulting means working with clients and client developers who are less experienced or less capable of writing the software they need. As a consultant your job is to help them build what they need while making a concerted effort to teach them how to continue building it once you’re gone.&lt;/p&gt;

&lt;p&gt;I had been merely a developer, not a consultant, for years. It’s probably the case that I imparted some knowledge onto the client developers I’ve worked with, but my primary motivation was writing good software at my pace, not being a good teacher. In that sense, I failed my clients.&lt;/p&gt;

&lt;h3 id=&#34;parting-words:d0e0ec411dac0f37b163e04611066dd6&#34;&gt;Parting words&lt;/h3&gt;

&lt;p&gt;I hope you’ve gotten out of this an understanding of what I believe it means to be a proper consultant, such that you might make an informed decision to decide whether or not consulting is for you.&lt;/p&gt;

&lt;p&gt;I decided it wasn’t for me; I wanted to build a product that I would own, where I would work only with people that were as capable as I was or moreso. By definition, not a consultant.&lt;/p&gt;

&lt;p&gt;Of course, you can join a consultancy and be just a developer, but if you do so you’re missing the point, and doing a disservice to your clients.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to set up a Clojure dev environment on Snow Leopard</title>
      <link>http://www.krishicks.com/post/how-to-set-up-a-clojure-dev-environment-on-snow-leopard/</link>
      <pubDate>Sat, 02 Feb 2013 00:00:00 +0000</pubDate>
      
      <guid>http://www.krishicks.com/post/how-to-set-up-a-clojure-dev-environment-on-snow-leopard/</guid>
      <description>

&lt;h3 id=&#34;homebrew-package-manager:705502c3dd033640148ad4a6c0cdaabc&#34;&gt;Homebrew (package manager)&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ ruby -e &amp;quot;$(curl -fsSkL raw.github.com/mxcl/homebrew/go)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More information on Homebrew can be found on the &lt;a href=&#34;http://mxcl.github.com/homebrew/&#34; title=&#34;Homebrew home page&#34;&gt;Homebrew home page&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;emacs-24-editor:705502c3dd033640148ad4a6c0cdaabc&#34;&gt;Emacs 24 (editor)&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ brew install emacs --cocoa --use-git-head --HEAD # this takes a while
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;emacs-prelude-enhanced-emacs-24-configuration:705502c3dd033640148ad4a6c0cdaabc&#34;&gt;Emacs Prelude (enhanced Emacs 24 configuration)&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ git clone git://github.com/bbatsov/prelude.git /path/to/prelude
$ ln -s /path/to/prelude ~/.emacs.d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More information on Prelude can be found on the &lt;a href=&#34;http://batsov.com/prelude/&#34; title=&#34;Prelude home page&#34;&gt;Prelude home page&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;paredit-emacs-minor-mode-for-editing-parentheses:705502c3dd033640148ad4a6c0cdaabc&#34;&gt;ParEdit (emacs minor mode for editing parentheses)&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ emacs
M-x package-install [RET] paredit [RET]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Add to ~/.emacs.d/init.el:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(add-hook &#39;nrepl-mode-hook &#39;paredit-mode)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;See the EmacsWiki: &lt;a href=&#34;http://emacswiki.org/emacs/ParEdit&#34; title=&#34;ParEdit&#34;&gt;ParEdit&lt;/a&gt; and &lt;a href=&#34;http://emacswiki.org/emacs/PareditCheatsheet&#34; title=&#34;ParEdit Cheatsheet&#34;&gt;ParEdit Cheatsheet&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;clojure:705502c3dd033640148ad4a6c0cdaabc&#34;&gt;Clojure&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/clojure/clojure.git /path/to/clojure
$ cd /path/to/clojure
$ ./antsetup.sh
$ ant
$ mkdir ~/.clojure
$ ln -s /path/to/clojure/clojure.jar ~/.clojure/clojure.jar
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;leiningen-clojure-automation-tool:705502c3dd033640148ad4a6c0cdaabc&#34;&gt;Leiningen (Clojure automation tool)&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$ wget -O /usr/local/bin/lein https://raw.github.com/technomancy/leiningen/preview/bin/lein
$ chmod 755 /usr/local/bin/lein
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More information on Leiningen can be found on the &lt;a href=&#34;http://leiningen.org/&#34; title=&#34;Leiningen home page&#34;&gt;Leiningen home page&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Finally:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ emacs
M-x nrepl-jack-in
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>rewinding git pull</title>
      <link>http://www.krishicks.com/post/rewinding-git-pull/</link>
      <pubDate>Mon, 09 Jul 2012 00:00:00 +0000</pubDate>
      
      <guid>http://www.krishicks.com/post/rewinding-git-pull/</guid>
      <description>&lt;p&gt;If you&amp;rsquo;re using a rebase strategy for the first time you may run &lt;code&gt;git pull&lt;/code&gt; in a situation where Git practically tells you to do it, but you don&amp;rsquo;t actually want to do it.&lt;/p&gt;

&lt;p&gt;The situation is described below, and the method to unwind it follows. I&amp;rsquo;ve added pictures of the branches between hashes to make it clear what the state of the world is at any given point prior to or after running a particular command, which I hope makes it easier to follow.&lt;/p&gt;

&lt;p&gt;First, you update master, as it&amp;rsquo;s out of date:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#############################
A--B--C--D origin/master
A--B--C master
#############################

(master) $ git pull
Updating C..D
Fast-forward
...snip...

#############################
A--B--C--D origin/master
A--B--C--D master
#############################
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You create and checkout a topic branch, topicA:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(master) $ git checkout -b topicA
Switched to a new branch &#39;topicA&#39;

#############################
A--B--C--D origin/master
A--B--C--D master
          \
           topicA
#############################
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You make some changes, commit, and push it to origin.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(topicA) $ git commit -am &amp;quot;Changed README&amp;quot;

#############################
A--B--C--D origin/master
A--B--C--D master
          \
           E topicA
#############################

(topicA) $ git push -u origin
(topicA) Counting objects: 28, done.
...snip...
(topicA)  * [new branch]      topicA -&amp;amp;gt; topicA
(topicA) Branch topicA set up to track remote branch topicA from origin.

#############################
A--B--C--D origin/master
A--B--C--D master
          \
           E topicA
A--B--C--D--E origin/topicA
#############################
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point you have your local topicA, and also origin has a copy of topicA:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(topicA) $ git branch -a
* topicA
remotes/origin/topicA
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You continue doing work, making more commits on your branch. Some time has passed since you branched from master, and another commit, F, has been pushed to origin/master.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(topicA) $ git fetch # to update your local repository&#39;s knowledge of the remote

#############################
A--B--C--D--F origin/master
A--B--C--D master
          \
           E--G--H topicA
A--B--C--D--E origin/topicA
#############################
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point you want to rebase on top of origin/master to get the updates (in this case, F).&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git rebase origin/master
First, rewinding head to replay your work on top of it...
...snip...

#############################
A--B--C--D--F origin/master
             \
              E&#39;--G&#39;--H&#39; topicA
A--B--C--D master
A--B--C--D--E origin/topicA
#############################
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then you want to push your updated topicA, with your new commits and the new commit from origin/master up to origin:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The following assumes you have &lt;code&gt;git config.push default upstream&lt;/code&gt; set. This configuration parameter limits the branch that git will attempt to push. I highly recommend you set that value as the default is to push &lt;em&gt;all&lt;/em&gt; branches, which you probably do not want.&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(topicA) $ git push
To git@github.com:intentmedia/code.git
! [rejected]        topicA -&amp;amp;gt; topicA (non-fast-forward)
error: failed to push some refs to &#39;git@github.com:krishicks/krishicks.git&#39;
To prevent you from losing history, non-fast-forward updates were rejected
Merge the remote changes (e.g. &#39;git pull&#39;) before pushing again.  See the
&#39;Note about fast-forwards&#39; section of &#39;git push --help&#39; for details.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is where trouble sets in.&lt;/p&gt;

&lt;p&gt;First, Git tells you the push was rejected because you would have lost history. Then comes the troublesome line: &amp;ldquo;Merge the remote changes (e.g. &amp;lsquo;git pull&amp;rsquo;) before pushing again.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;If you were working on master and made some commits, and someone else made some commits on master as well and pushed before you did, you would end up with the same situation as above. The push would be rejected because you don&amp;rsquo;t have the commits that the other person made. Thus, if your push were to succeed their work would be lost on origin/master. This is what Git is referring to when it says &amp;ldquo;To prevent you from losing history..&amp;rdquo; The history that would be lost would be the work the other person did.&lt;/p&gt;

&lt;p&gt;In the situation we&amp;rsquo;ve been building up, making commits and rebasing topicA, you&amp;rsquo;re the only person committing to the branch and the history you would &amp;ldquo;lose&amp;rdquo; is the set of pre-rebase commits that you pushed to the remote originally (in this case, E). You&amp;rsquo;ve overwritten E with E&amp;rsquo; during the rebase, and Git doesn&amp;rsquo;t want you to lose the E that&amp;rsquo;s on the remote.&lt;/p&gt;

&lt;p&gt;What you should do in this situation is &lt;code&gt;git push -f&lt;/code&gt; to force-push the branch. You know you&amp;rsquo;re going to lose E that&amp;rsquo;s on the remote, but that&amp;rsquo;s fine because you have E&amp;rsquo; on your local topicA. You intend to replace whatever is on the remote with whatever you have locally.&lt;/p&gt;

&lt;p&gt;The problem is that it says to do a &lt;code&gt;git pull&lt;/code&gt;, which will pull the remote E into your local, which you don&amp;rsquo;t want. That will give you a merge commit, I:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A--B--C--D--F origin/master
             \
              E&#39;--G&#39;--H&#39; topicA
                       \
                        I
A--B--C--D master      /
A--B--C--D------------E origin/topicA
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you did a git log at this point you&amp;rsquo;d see that the merge commit I brought in E, which has the same message but a different SHA than your rebased E&amp;rsquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(topicA) $ git log --graph --oneline
* I Merge branch &#39;origin/topicA&#39; into topicA
|
| * E
* | H&#39;
* | G&#39;
* | E&#39;
|/
* D
* C
* B
* A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So, how do you fix this? You can hard reset back to H&amp;rsquo;, which gets rid of the merge commit, but &lt;strong&gt;only if you didn&amp;rsquo;t already make more commits after the faulty &lt;code&gt;git pull&lt;/code&gt;.&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(topicA) $ git reset --hard H&#39; # Only if you didn&#39;t make any more commits!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you have made commits after, with your log looking like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(topicA) $ git log --graph --oneline
* K
* J
* I Merge branch &#39;origin/topicA&#39; into topicA
|
| * E
* | H&#39;
* | G&#39;
* | E&#39;
|/
* D
* C
* B
* A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You need to use the two-argument form of &lt;a href=&#34;https://pivotallabs.com/users/khicks/blog/articles/2118-git-rebase-onto&#34; title=&#34;git rebase --onto&#34;&gt;git rebase &amp;ndash;onto&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(topicA) $ git rebase --onto H&#39; J~1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That will get rid of the merge commit, leaving you with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(topicA) $ git log --graph --oneline
* K
* J
* H&#39;
* G&#39;
* E&#39;
* D
* C
* B
* A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now you can &lt;code&gt;git push -f&lt;/code&gt;. The &lt;a href=&#34;http://linux.die.net/man/1/git-push&#34; title=&#34;docs on git-push&#34;&gt;docs on git-push&lt;/a&gt; (or &lt;code&gt;git push --help&lt;/code&gt;) do give you a better explanation than the message when the push is rejected, in the section NOTE ABOUT FAST-FORWARDS.&lt;/p&gt;

&lt;p&gt;A simple rule about &lt;code&gt;git pull&lt;/code&gt; is to not ever use it unless you&amp;rsquo;re on master and have made no commits that put you ahead of origin/master, which you can easily tell with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(master) $ git fetch
(master) $ git log @{u}..
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(master) $ git fetch
(master) $ git status
# On branch master
nothing to commit (working directory clean)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the result from &lt;code&gt;git log @{u}&lt;/code&gt; is empty or you don&amp;rsquo;t get &amp;ldquo;# Your branch is ahead of &amp;lsquo;origin/master&amp;rsquo; by  commit(s)&amp;rdquo; message after &lt;code&gt;git status&lt;/code&gt;, you&amp;rsquo;re OK to &lt;code&gt;git pull&lt;/code&gt;. In no other case do you need to, or should you, &lt;code&gt;git pull&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;I generally recommend always working on a topic branch and keeping master clean to avoid accidentally running &lt;code&gt;git push -f&lt;/code&gt; on master, and to enforce the idea that after you fetch, you&amp;rsquo;re rebasing on top of origin/master directly instead of doing &lt;code&gt;git pull --rebase&lt;/code&gt; while on master, which hides the fact that you&amp;rsquo;re rebasing on top of origin/master.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>git quick tips</title>
      <link>http://www.krishicks.com/post/quick-tips/</link>
      <pubDate>Tue, 03 Jul 2012 00:00:00 +0000</pubDate>
      
      <guid>http://www.krishicks.com/post/quick-tips/</guid>
      <description>

&lt;p&gt;The following are things I found very helpful, which you also may find make your day-to-day usage of Git more enjoyable.&lt;/p&gt;

&lt;h2 id=&#34;go-headless:afd8b67611add8867d2e29eb12d8ce6a&#34;&gt;Go HEADless&lt;/h2&gt;

&lt;p&gt;In many (and perhaps all) cases HEAD is implied when no ref is given, such as the following equivalent statements:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log origin/master..HEAD
$ git log origin/master..
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;upstream-reference:afd8b67611add8867d2e29eb12d8ce6a&#34;&gt;Upstream reference&lt;/h2&gt;

&lt;p&gt;Before you start referring to the upstream, you&amp;rsquo;ll want to do a &lt;code&gt;git fetch&lt;/code&gt; to update your refs/heads:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git fetch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You only need to do this once in a while, or whenever you know the upstream to have changed.&lt;/p&gt;

&lt;p&gt;You can refer to the upstream of any branchname or otherwise symbolic-ref by appending &lt;code&gt;@{u}&lt;/code&gt; to the ref, such as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log master@{u}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you just want the upstream of the current branch, whatever it may be, you can replace master from above with HEAD:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log HEAD@{u}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;upstream-difference:afd8b67611add8867d2e29eb12d8ce6a&#34;&gt;Upstream difference&lt;/h2&gt;

&lt;p&gt;Often, I&amp;rsquo;ll want to see what commits are on upstream that I don&amp;rsquo;t have. I usually will do this via:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log @{u}..
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which, when on master, is equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log origin/master..HEAD
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see the reverse difference, or the commits are on the remote that you don&amp;rsquo;t have, by reversing the range:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log ..@{u}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which, again on master, is equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log HEAD..origin/master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;To see the full list of formats recognizable, see &lt;code&gt;git revisions --help&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;If you want to see both of the above at the same time, you can use &lt;code&gt;git log&lt;/code&gt; with the &amp;ndash;left-right parameter. I&amp;rsquo;ve also included &amp;ndash;format=&amp;rdquo; and &amp;ndash;oneline (which must be passed in that order), which may be optional depending on your format configuration, but for me are not:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log HEAD@{u}...HEAD --left-right --format=&#39;&#39; --oneline
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which can be shortened to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log @{u}... --left-right --format=&#39;&#39; --oneline
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Note: The above example uses three dots, not two, to show only the commits which are reachable as ancestors of one branch but not the other.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;You can replace HEAD in the above with any symbolic-ref or branchname to use as a reference instead. The output (with the format given previously) will look like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt; e86bd83 D
&amp;lt; 6ea2155 C
&amp;gt; eb2de55 B
&amp;gt; 74829bd A
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Commits beginning with &amp;ldquo;&amp;lt;&amp;rdquo; are only on the left side of the triple-dot (in this case, the upstream), commits beginning with &amp;ldquo;&amp;gt;&amp;rdquo; are only on the right side (in this case, the current branch). A..D are the commit messages.&lt;/p&gt;

&lt;h2 id=&#34;is-it-merged:afd8b67611add8867d2e29eb12d8ce6a&#34;&gt;Is it merged?&lt;/h2&gt;

&lt;p&gt;To find out if a particular branch has been merged into origin/master, you could dig through the log on master and search for it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log origin/master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or, if you knew who would have merged it, you could limit the above with that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git log origin/master --author Kris
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I wanted a better way, and I found it. I wanted to see if a particular branch had been merged to master without changing branches or having to dig through a log looking for the merge of the branch.&lt;/p&gt;

&lt;p&gt;The situation that prompted this was that I had a topic branch, topicB, which depended on another topic branch, topicA. I wanted to see if topicA had been merged into master to find out if I could rebase onto master to get up to date, or if I should continue rebasing on top of the branch.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git fetch
$ git branch --contains topicB@{u} -r
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This gives you a list of all the remote branches that can reach (as an ancestor) the ref given. origin/master will be right at the top if the branch has been merged into it.&lt;/p&gt;

&lt;p&gt;Many thanks to &lt;a href=&#34;http://newartisans.com/2008/04/git-from-the-bottom-up/&#34; title=&#34;John Wiegley&#34;&gt;John Wiegley&lt;/a&gt;, &lt;a href=&#34;http://www.git-scm.com/book&#34; title=&#34;Scott Chacon&#34;&gt;Scott Chacon&lt;/a&gt; and &lt;a href=&#34;http://serverfault.com/a/384862&#34; title=&#34;Mark Longair&#34;&gt;Mark Longair&lt;/a&gt; for the sources of the tips.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>rewinding git commit --amend</title>
      <link>http://www.krishicks.com/post/rewinding-git-commit-amend/</link>
      <pubDate>Mon, 25 Jun 2012 00:00:00 +0000</pubDate>
      
      <guid>http://www.krishicks.com/post/rewinding-git-commit-amend/</guid>
      <description>&lt;p&gt;It may come to pass that you will &lt;code&gt;git commit --amend&lt;/code&gt; by mistake.&lt;/p&gt;

&lt;p&gt;When this happens, you&amp;rsquo;ll want to rewind that operation you just did, and apply it to the correct commit. With simple changes you may find &lt;a href=&#34;http://www.krishicks.com/blog/2012/05/16/git-reset-p/&#34; title=&#34;git reset -p&#34;&gt;git reset -p&lt;/a&gt; handy. For times when the changes are far too large and intertwined to the commit, you will want to refer to &lt;code&gt;git reflog&lt;/code&gt; for help.&lt;/p&gt;

&lt;p&gt;The reflog records when the tip of a branch is updated. The tip is updated any time you create a new commit, amend a commit, reset a commit, switch branches, etc. Basically, any time HEAD changes, you will get a reflog entry. The reflog therefore is a great tool for understanding how the repository came to be in a particular state.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git reflog -2&lt;/code&gt; will give you the last two operations that Git performed. In this case, it will look something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;8751261 HEAD@{0}: commit (amend): Something something something commit message
9d3a192 HEAD@{1}: reset: moving to HEAD~1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;git commit --amend&lt;/code&gt; is kind of shorthand for (given changes have been made, and are either in the index or in the working directory):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git stash
git reset HEAD~1
git stash pop
git add .
git commit
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or, in English:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Save the changes that you want to apply to the HEAD commit off in the stash&lt;/li&gt;
&lt;li&gt;Remove the HEAD commit and put its contents in the index&lt;/li&gt;
&lt;li&gt;Apply the stashed changes to the working directory, adding them to the changes from the commit that was reset&lt;/li&gt;
&lt;li&gt;Make a new commit.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Thus, the last two operations in the reflog are &lt;strong&gt;reset&lt;/strong&gt; and &lt;strong&gt;commit&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;So, what can we do with this? Well, 9d3a192 was HEAD before the amend (specifically, before the reset) happened. 8751261 was the commit that resulted at the end of the amend process. &lt;code&gt;git diff 8751261..9d3a192&lt;/code&gt; will show you what changes were applied as part of the amend.&lt;/p&gt;

&lt;p&gt;From here, you can use &lt;code&gt;git apply&lt;/code&gt; to apply the difference from before the amend to after the amend to your working tree via &lt;code&gt;git diff&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git diff 8751261..9d3a192 | git apply -
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Note: The hyphen in &lt;code&gt;git apply -&lt;/code&gt; causes &lt;code&gt;git apply&lt;/code&gt; to take stdin as input.&lt;/li&gt;
&lt;li&gt;Extra Note: The arguments here are given in reverse order, with the later commit happening first to show the reverse of the amend. It&amp;rsquo;s the same as doing &lt;code&gt;git diff 9d3a192..8751261 -R&lt;/code&gt;, which reverses the diff output. Additionally, the -R argument may be applied to &lt;code&gt;git apply&lt;/code&gt; instead of &lt;code&gt;git diff&lt;/code&gt; to achieve the same effect.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now we can do another amend to put the commit back to where it was before we did the previous amend:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git commit -a --amend -CHEAD
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then, by reversing the order of the SHAs to &lt;code&gt;git diff&lt;/code&gt;, get the changes we want to apply to the correct commit back:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git diff 9d3a192..8751261 | git apply -
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And commit as necessary, this time using &amp;ndash;fixup to indicate the correct commit (in this example, 1234567):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git commit -a --fixup 1234567
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then you can rebase at a later time (or now) to do the &amp;lsquo;amend&amp;rsquo; you had originally intended:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git rebase --i --autosquash 1234567~1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So don&amp;rsquo;t fret when you do an accidental amend. It&amp;rsquo;s just a couple commands away from being unwound and applied to the correct commit.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>rerere</title>
      <link>http://www.krishicks.com/post/rerere/</link>
      <pubDate>Wed, 13 Jun 2012 00:00:00 +0000</pubDate>
      
      <guid>http://www.krishicks.com/post/rerere/</guid>
      <description>&lt;p&gt;There have been times where I performed a rebase and had to resolve conflicts as part of the rebase, and then decided to abort the rebase for one reason or another.&lt;/p&gt;

&lt;p&gt;Without &lt;code&gt;rerere&lt;/code&gt; the next time I went to perform the rebase I&amp;rsquo;d end up having to resolve at least some of the same conflicts I had previously, which is annoying.&lt;/p&gt;

&lt;p&gt;This is where &lt;code&gt;rerere&lt;/code&gt; comes in.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;rerere&amp;rdquo; stands for &lt;strong&gt;re&lt;/strong&gt;use &lt;strong&gt;re&lt;/strong&gt;corded &lt;strong&gt;re&lt;/strong&gt;solution.&lt;/p&gt;

&lt;p&gt;What &lt;code&gt;rerere&lt;/code&gt; does is save the resolution of a conflict so that it can be re-applied later if it sees the same conflict again. When Git sees the conflict which it already has a resolution recorded for, it will apply the resolution automatically for you, and give you the opportunity to accept the resolution as applied, or change it.&lt;/p&gt;

&lt;p&gt;Turning it on can be done two ways: set it as a configuration parameter using &lt;code&gt;git config rerere.enabled true&lt;/code&gt;, or use it only when you think you might need it with &lt;code&gt;git rerere&lt;/code&gt; both before and after the resolution of a conflict.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;A more verbose explanation of &lt;code&gt;rerere&lt;/code&gt; exists in Scott Chacon&amp;rsquo;s &lt;strong&gt;Pro Git&lt;/strong&gt;&lt;/em&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>git rebase --onto</title>
      <link>http://www.krishicks.com/post/git-rebase-onto/</link>
      <pubDate>Mon, 28 May 2012 00:00:00 +0000</pubDate>
      
      <guid>http://www.krishicks.com/post/git-rebase-onto/</guid>
      <description>

&lt;p&gt;Have you ever dug into the &lt;code&gt;git rebase&lt;/code&gt; documentation and noticed there&amp;rsquo;s a three-argument form of it?&lt;/p&gt;

&lt;p&gt;First, let&amp;rsquo;s look at the two-argument form, and build up to the three-argument form.&lt;/p&gt;

&lt;h2 id=&#34;the-two-argument-form-of-git-rebase-onto:300784076f766c8d506d5084e888decd&#34;&gt;The two-argument form of git rebase &amp;ndash;onto&lt;/h2&gt;

&lt;p&gt;Say there&amp;rsquo;s a commit C made on master that made a change to a configuration parameter that, it turns out, wasn&amp;rsquo;t actually necessary, so that commit needs to go. For the purposes of this demonstration, commits D and E don&amp;rsquo;t rely upon the changes made in C. &amp;#40;If D or E did rely on C, you&amp;rsquo;d end up with a conflict to resolve, which you&amp;rsquo;d be able to do at that point.&amp;#41;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A--B--C--D--E master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One way to get rid of the offending commit would be to do an interactive rebase, deleting the line that has commit C on it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git rebase -i C~1
delete the line containing commit C
save and close the editor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A quicker way is to use the two-argument &lt;code&gt;git rebase --onto&lt;/code&gt;, as going interactive just to delete a commit &amp;#40;or commits&amp;#41; is a little overkill, and considerably slower to do.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git rebase --onto&lt;/code&gt; takes a new base commit &amp;#40;which the manpage for git-rebase calls newbase&amp;#41; and an old base commit &amp;#40;oldbase&amp;#41; to use for the rebase operation.&lt;/p&gt;

&lt;p&gt;So, what we want to do is tell Git to make commit B the newbase of commit D, making C go away. This looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git rebase --onto B C
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But usually I like to talk about the commits I care about rather than the ones I don&amp;rsquo;t &amp;#40;in this case, I care about B and D, but not C&amp;#41;, so instead of the previous command I use a backreference from D:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git rebase --onto B D~1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This means that everything in the range from B &amp;#40;non-inclusive&amp;#41; to D~1 &amp;#40;inclusive&amp;#41; &lt;em&gt;will be removed&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git rebase --onto&lt;/code&gt; allows you to, in a non-interactive way, change the base of a commit, or &lt;em&gt;rebase&lt;/em&gt; it. If you think about the commits as each having a &lt;strong&gt;base&lt;/strong&gt;, or &lt;strong&gt;parent&lt;/strong&gt; commit, you can see how you might be able to change the base of any commit to be another commit. In doing so, you remove everything that used to be in between the oldbase and the newbase.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s also good to know that it works exactly the same way as if you were to have done an interactive rebase and deleted the commit. Should a conflict arise while performing the rebase, Git will still pause and allow you to resolve the conflict before continuing.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve also used the two-argument form when fixing a mistake: I had a branch from master, topicA, with some commits that I wanted to change via interactive rebase:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A--B master
    \
     C--D--E topicA
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But when I rebased, I went back too far, and rewrote a commit that I had gotten from master:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A--B&#39; master
    \
     C&#39;--D&#39;--E&#39; topicA
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#40;Note that there was no change to the master branch here, just to topicA.&amp;#41;&lt;/p&gt;

&lt;p&gt;What did I do to fix this situation? Well, I can&amp;rsquo;t fix this via interactive rebase. I can, however, fix it via &lt;code&gt;git rebase --onto&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git rebase --onto master C&#39;~1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or, in other words: Replace the oldbase C&amp;rsquo;~1 with the newbase, master &amp;#40;which is HEAD of master, or B&amp;#41;.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s a handy undo mechanism.&lt;/p&gt;

&lt;p&gt;If you forget to give the two-argument form of &amp;ndash;onto its second argument, such as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git rebase --onto master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;..it will be the same as doing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git reset --hard master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;You probably don&amp;rsquo;t want this.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Why is this? The second argument &amp;#40;the oldbase&amp;#41; is required if you want a range of commits to be applied on top of master. Without it, you haven&amp;rsquo;t supplied a range of commits to be applied on top of master, so HEAD of the branch gets reset to the HEAD of master.&lt;/p&gt;

&lt;p&gt;What that means is any commits you have on your branch will be removed from the branch, and the branch will resemble master at that point. These commits are still in Git until garbage collection happens, accessible via the reflog &amp;#40;&lt;code&gt;git reflog&lt;/code&gt;&amp;#41;.&lt;/p&gt;

&lt;h1 id=&#34;part-two:300784076f766c8d506d5084e888decd&#34;&gt;Part Two:&lt;/h1&gt;

&lt;h2 id=&#34;the-three-argument-form-of-git-rebase-onto:300784076f766c8d506d5084e888decd&#34;&gt;The three-argument form of git rebase &amp;ndash;onto&lt;/h2&gt;

&lt;p&gt;Say there is a branch &amp;lsquo;topicA&amp;rsquo; that diverges from master at some point:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A--B--C--D--E master
    \
     F--G--H topicA
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s also say that someone else has branched from topicA to create topicB, and added more commits:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A--B--C--D--E master
    \
     F--G--H topicA
            \
             I--J--K--L--M topicB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is an example of a real-world case I came across, where topicA had only a couple very large commits that were hard to digest and could have been split into many smaller commits. topicB was created as a continuation of the work done on topicA.&lt;/p&gt;

&lt;p&gt;I checked out my own local copy of topicA, and through much interactive rebasing and prodigious use of &lt;code&gt;git add -e&lt;/code&gt;, I was able to split topicA into smaller commits, making topicC:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A--B--C--D--E master
   |         \
   |          F--G--H topicA
   |                 \
   |                  I--J--K--L--M topicB
   |
   N--O--P--Q--R--S--T--U--V--W topicC
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I talked with the person that made topicA and we agreed that my branch topicC should take the place of topicA. But what to do about the work that was done on topicB?&lt;/p&gt;

&lt;p&gt;The operation that we wanted to do is: make topicC the new base of topicB, cutting it at the point topicB diverged from topicA, which looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A--B--C--D--E master
   |         \
   |          F--G--H topicA
   |                 \
   |                  I--J--K--L--M topicB
   |
   N--O--P--Q--R--S--T--U--V--W--I&#39;--J&#39;--K&#39;--L&#39;--M&#39; topicC
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The five commits from topicB &amp;#40;I through M&amp;#41;, get played on top of topicC, starting from where topicB diverged from topicA, to create I&amp;rsquo;, J&amp;rsquo;, K&amp;rsquo;, L&amp;rsquo;, and M&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;The command to do this is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git rebase --onto topicC topicA topicB
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where topicC is the newbase, topicA is the oldbase, and topicB is the reference for what HEAD of topicC will become.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>git add -e</title>
      <link>http://www.krishicks.com/post/git-add-e/</link>
      <pubDate>Mon, 21 May 2012 00:00:00 +0000</pubDate>
      
      <guid>http://www.krishicks.com/post/git-add-e/</guid>
      <description>&lt;p&gt;&lt;code&gt;git add -e&lt;/code&gt; is like &lt;code&gt;git add -p&lt;/code&gt;, except instead of adding things at the hunk level, you edit the entire patch at once.&lt;/p&gt;

&lt;p&gt;Or, in other words, whereas &lt;code&gt;git add -p&lt;/code&gt; will show you each hunk for every file and ask what you want to do for each of them, &lt;code&gt;git add -e&lt;/code&gt; will show you the entire patch and allow you to edit it at will. I used this trick to recently split apart one massive commit into 28 smaller, digestible ones.&lt;/p&gt;

&lt;p&gt;Say you&amp;rsquo;ve replaced a line containing &amp;ldquo;baz&amp;rdquo; with one containing &amp;ldquo;bar&amp;rdquo;. When you &lt;code&gt;git add -e&lt;/code&gt;, you&amp;rsquo;ll be presented with a diff like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo
- baz
+ bar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;From here you can decide, actually, you don&amp;rsquo;t want to delete baz, you just want to add bar. And you want to add it above baz.&lt;/p&gt;

&lt;p&gt;From this spot you can just change the minus to a space, making that line context for the diff. Then you can move the line that adds bar above baz, with this result:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo
+ bar
baz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After saving and closing the editor you&amp;rsquo;ll be able to look at the result of your work in the index with &lt;code&gt;git diff --cached&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo
+ bar
baz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the line you made into context remains in your working directory, which you can see with &lt;code&gt;git diff&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo
bar
-baz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But what if you end up modifying the diff in a way that makes it a patch that doesn&amp;rsquo;t apply? Git&amp;rsquo;s got you covered there.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say that when you moved bar above baz, after removing the minus from baz, you added an extra line on accident, making the patch invalid:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo

+ bar
baz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you save and close the editor Git will tell you of the problem:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error: patch failed: &amp;amp;lt;some_filename&amp;amp;gt;:1
error: file.txt: patch does not apply
fatal: Could not apply &#39;.git/ADD_EDIT.patch&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In which case you&amp;rsquo;ll be able to attempt the &lt;code&gt;add -e&lt;/code&gt; again, as Git will not have made any changes to the working directory or index at this point.&lt;/p&gt;

&lt;p&gt;In some cases Git will attempt to apply the patch and give you the option of retrying the add, re-opening the editor with the modified .git/ADD_EDIT.patch if you choose to retry. If you don&amp;rsquo;t choose to retry, Git will delete .git/ADD_EDIT.patch.&lt;/p&gt;

&lt;p&gt;In addition to editing the patch wholesale via &lt;code&gt;git add -e&lt;/code&gt;, you can also choose &lt;em&gt;during &lt;code&gt;git add -p&lt;/code&gt;&lt;/em&gt; to edit a particular hunk manually by choosing &amp;lsquo;e&amp;rsquo; to edit it instead of simply adding it via &amp;lsquo;a&amp;rsquo;. You can also add a file glob to the end of &lt;code&gt;add -e&lt;/code&gt; as you would any other command to limit the size of the patch you&amp;rsquo;re about to edit.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>git reset -p</title>
      <link>http://www.krishicks.com/post/git-reset-p/</link>
      <pubDate>Wed, 16 May 2012 00:00:00 +0000</pubDate>
      
      <guid>http://www.krishicks.com/post/git-reset-p/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve been using &lt;code&gt;git reset -p&lt;/code&gt; a lot recently and I think it makes sense to clarify what it is that it does because when I first started using it I found it a little confusing.&lt;/p&gt;

&lt;p&gt;I sometimes realize that an earlier commit contains some change that I don&amp;rsquo;t want, so I want to remove it from the commit. This also works when not rebasing, so for simplicity I&amp;rsquo;ll use an example where the commit to be modified is already HEAD. Previously I would have done:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git reset HEAD~1
git add -p
git commit -C &amp;lt;treeish&amp;gt;
git checkout .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or, in English:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;take off the HEAD commit, adding it to the working directory&lt;/li&gt;
&lt;li&gt;add back the parts you want to keep&lt;/li&gt;
&lt;li&gt;make a new commit using the message from what used to be the HEAD commit&lt;/li&gt;
&lt;li&gt;throw away the changes you didn&amp;rsquo;t want&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With git reset -p this process is a little different. Here&amp;rsquo;s what it looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git reset -p HEAD~1
git commit --amend -C HEAD
git checkout .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, in English:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;apply to the index the negations of certain parts of the HEAD commit&lt;/li&gt;
&lt;li&gt;amend the HEAD commit with the negations&lt;/li&gt;
&lt;li&gt;throw away the changes you don&amp;rsquo;t want&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;How does this work?&lt;/p&gt;

&lt;p&gt;In the second example you added &lt;code&gt;-p&lt;/code&gt; to the &lt;code&gt;reset&lt;/code&gt; command. This will reset only parts of the original commit, leaving it intact otherwise. That&amp;rsquo;s worth stating a different way: When you &lt;code&gt;reset -p&lt;/code&gt;, &lt;strong&gt;the original commit remains unchanged&lt;/strong&gt;. The only changes are made to your working directory and index.&lt;/p&gt;

&lt;p&gt;The trick is to know what you&amp;rsquo;re doing when you&amp;rsquo;re saying &amp;ldquo;y&amp;rdquo; to a hunk git presents to you for resetting. Say you added a line to the commit originally:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo
+ bar
baz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But you want to get rid of it. When you git reset -p, git will ask you:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo
- bar
baz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apply this hunk to index [y,n,q,a,d,/,e,?]?&lt;/p&gt;

&lt;p&gt;If you say &amp;lsquo;y&amp;rsquo;, Git will apply that hunk to the index. What you also get, however, is the original hunk (that added &amp;ldquo;bar&amp;rdquo;) in your working directory.&lt;/p&gt;

&lt;p&gt;To summarize, your working directory will have:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo
+ bar
baz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While the index has:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foo
- bar
baz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While the commit (unchanged, remember) has:
    foo
    + bar
    baz&lt;/p&gt;

&lt;p&gt;You now have a chance to tell git what you want to do, without having done anything to the original commit yet. In the example above, you wanted to get rid of the addition of the &amp;ldquo;bar&amp;rdquo; line. To do that, you want to take what&amp;rsquo;s in the index (the negation of the addition of &amp;ldquo;bar&amp;rdquo;) and apply it to the commit, making it go away:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git commit --amend -C HEAD
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then you still have in your working directory the adding of &amp;ldquo;bar&amp;rdquo;, which in this case you just want to get rid of, so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git checkout .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I like using &lt;code&gt;reset -p&lt;/code&gt; because it makes it really easy to make small changes to a commit, removing something I added or putting back something I deleted.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;reset -p&lt;/code&gt; allows you to more easily get a grip on the changes you&amp;rsquo;ve made and the ones you&amp;rsquo;re about to make. It also makes much better use of Git, in that you can do even more interesting operations when in the resulting state, which I won&amp;rsquo;t go into now as to avoid information overload.&lt;/p&gt;

&lt;p&gt;And there you have it.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>git exec</title>
      <link>http://www.krishicks.com/post/exec/</link>
      <pubDate>Fri, 06 Apr 2012 00:00:00 +0000</pubDate>
      
      <guid>http://www.krishicks.com/post/exec/</guid>
      <description>&lt;p&gt;(Update #1 below)&lt;/p&gt;

&lt;p&gt;Say you&amp;rsquo;re going to do an interactive rebase where you&amp;rsquo;re going to be squashing commits or reordering them. During this process you may want Git to execute a command after applying certain items of the todo list. An example of this would be when you want to run &lt;code&gt;rake&lt;/code&gt; or similar to ensure a newly-squashed commit is still green.&lt;/p&gt;

&lt;p&gt;You can do this by adding a task to the todo list, &lt;code&gt;exec&lt;/code&gt;, followed by the command you&amp;rsquo;d like Git to run at that point in the rebase. If the command you specify should return a non-zero exit code, Git will pause the rebase and allow you to sort it out, in the same way that it pauses when a conflict arises while applying the todo list during any other rebase.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an example of the above situation, where two commits are going to be squashed, and I want Git to run &lt;code&gt;rake&lt;/code&gt; after it does the squash.&lt;/p&gt;

&lt;p&gt;Pre-edits, this would look like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pick dad8d12 Commit #1
pick f613ac1 Commit #2
pick 58822ee Commit #3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Post-edits, this would look like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pick dad8d12 Commit #1
f f613ac1 Commit #2
x rake
pick 58822ee Commit #3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What happens here is Git will fixup Commit #2 into Commit #1, creating a new commit, then run &lt;code&gt;rake&lt;/code&gt;. If &lt;code&gt;rake&lt;/code&gt; returns a zero exit code, Git applies Commit #3 and completes the rebase. If &lt;code&gt;rake&lt;/code&gt; had returned a non-zero exit code, Git would have paused the rebase operation at that point, allowing any necessary changes to be made to the HEAD commit, which is the squashed #1/#2.&lt;/p&gt;

&lt;p&gt;I typically do this separate from doing an initial rebase, where I rebased and made a change to Commit #1 and had to resolve conflicts throughout the rest of the commits. This way I can keep my head straight while doing the rebase, then fix anything I missed as a second operation.&lt;/p&gt;

&lt;p&gt;Update #1: As of Git 1.7.12 you can pass &lt;code&gt;-x &amp;lt;cmd&amp;gt;&lt;/code&gt; to &lt;code&gt;git rebase -i&lt;/code&gt; to have Git run the exec command after every commit in the resulting history: &lt;code&gt;git rebase -i &amp;lt;treeish&amp;gt; -x &amp;lt;cmd&amp;gt;&lt;/code&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://www.krishicks.com/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://www.krishicks.com/about/</guid>
      <description>

&lt;h1 id=&#34;hi:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;Hi,&lt;/h1&gt;

&lt;p&gt;I&amp;rsquo;m Kris.&lt;/p&gt;

&lt;p&gt;I taught myself Ruby in 2007 to solve a data entry problem. I did a couple of presentations on the automation framework I wrote and ended up getting a job at &lt;a href=&#34;http://www.thoughtworks.com&#34;&gt;ThoughtWorks&lt;/a&gt;, where I hoped to (and did) grow as a developer by learning from highly talented people.&lt;/p&gt;

&lt;p&gt;I then moved to NYC and joined &lt;a href=&#34;http://www.pivotallabs.com&#34;&gt;Pivotal Labs&lt;/a&gt;, where I continued to grow and learn new technologies: I helped write an &lt;a href=&#34;http://flywheel.com/san-francisco&#34;&gt;iOS app&lt;/a&gt;, had my first foray into Java at &lt;a href=&#34;http://intentmedia.com&#34;&gt;Intent Media&lt;/a&gt;, and continued to build my knowledge of &lt;a href=&#34;http://www.rubyonrails.org&#34;&gt;Rails&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I left Pivotal Labs for a startup, &lt;a href=&#34;http://www.daisybill.com&#34;&gt;DaisyBill&lt;/a&gt;, where I ended up becoming the CTO and sole developer until I left to do contract work at &lt;a href=&#34;http://www.pivotal.io&#34;&gt;Pivotal&lt;/a&gt; in San Francisco, where I worked on two parts of &lt;a href=&#34;http://pivotal.io/platform-as-a-service/pivotal-cloud-foundry&#34;&gt;CloudFoundry&lt;/a&gt;, &lt;a href=&#34;http://www.bosh.io&#34;&gt;BOSH&lt;/a&gt; and &lt;a href=&#34;https://github.com/cloudfoundry-incubator/diego-design-notes&#34;&gt;Diego&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I am presently working at Pivotal as a Solutions Architect for CloudFoundry out of San Francisco.&lt;/p&gt;

&lt;p&gt;My resume is available on &lt;a href=&#34;https://github.com/krishicks/resume/blob/master/resume.md&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;thanks:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;Thanks&lt;/h3&gt;

&lt;p&gt;I wouldn&amp;rsquo;t be the engineer I am today without the support from the following people (and many others):
  &lt;a href=&#34;https://www.twitter.com/adammilligan&#34;&gt;Adam Milligan&lt;/a&gt;,
  &lt;a href=&#34;https://www.twitter.com/aghareza&#34;&gt;Ali Aghareza&lt;/a&gt;,
  &lt;a href=&#34;https://www.linkedin.com/pub/alisa-lamacki/b/2a8/aa5&#34;&gt;Alisa Lamacki&lt;/a&gt;,
  &lt;a href=&#34;https://www.twitter.com/bguthrie&#34;&gt;Brian Guthrie&lt;/a&gt;,
  &lt;a href=&#34;https://www.twitter.com/nertzy&#34;&gt;Grant Hutchins&lt;/a&gt;,
  &lt;a href=&#34;https://www.twitter.com/duelinmarkers&#34;&gt;John Hume&lt;/a&gt;,
  &lt;a href=&#34;https://twitter.com/cuberick&#34;&gt;Josh Cronemeyer&lt;/a&gt;,
  &lt;a href=&#34;https://www.twitter.com/joshknowles&#34;&gt;Josh Knowles&lt;/a&gt;,
  &lt;a href=&#34;https://www.twitter.com/schubertcx&#34;&gt;Michael Schubert&lt;/a&gt;,
  &lt;a href=&#34;https://www.twitter.com/pgr0ss&#34;&gt;Paul Gross&lt;/a&gt;,
  &lt;a href=&#34;http://www.pivotallabs.com/team/executives/&#34;&gt;Rob Mee&lt;/a&gt;,
  &lt;a href=&#34;https://www.twitter.com/samcoward&#34;&gt;Sam Coward&lt;/a&gt;,
  &lt;a href=&#34;https://www.twitter.com/stevesalkin&#34;&gt;Steve Salkin&lt;/a&gt;,
  and
  &lt;a href=&#34;https://www.twitter.com/pitluga&#34;&gt;Tony Pitluga&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>